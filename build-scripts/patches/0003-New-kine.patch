From 3777d33ec2b5586a9ea8d33758622bb2224c539f Mon Sep 17 00:00:00 2001
From: Konstantinos Tsakalozos <kos.tsakalozos@canonical.com>
Date: Tue, 1 Jun 2021 22:58:28 +0300
Subject: [PATCH] New kine

---
 cmd/kube-apiserver/app/server.go              |   3 +-
 .../github.com/canonical/kvsql-dqlite/LICENSE |   1 +
 .../github.com/canonical/kvsql-dqlite/go.mod  |   4 +-
 .../github.com/canonical/kvsql-dqlite/go.sum  |   4 +
 .../canonical/kvsql-dqlite/server/server.go   |  48 ++-
 vendor/github.com/k3s-io/kine/.drone.yml      | 261 ++++++++++++++
 .../{rancher => k3s-io}/kine/.gitignore       |   9 +-
 vendor/github.com/k3s-io/kine/.golangci.json  |  13 +
 .../{rancher => k3s-io}/kine/Dockerfile       |   0
 .../github.com/k3s-io/kine/Dockerfile.dapper  |  23 ++
 .../k3s-io/kine/Dockerfile.test.dapper        |  16 +
 .../{rancher => k3s-io}/kine/LICENSE          |   1 +
 .../{rancher => k3s-io}/kine/README.md        |  10 +-
 .../kine/examples/generate-certs.sh           |   1 +
 .../kine/examples/minimal.md                  |   6 +-
 .../kine/examples/mysql-ssl.cnf               |   0
 .../{rancher => k3s-io}/kine/go.mod           |   8 +-
 .../{rancher => k3s-io}/kine/go.sum           |   8 +-
 .../github.com/k3s-io/kine/hack/histogram.py  |  82 +++++
 vendor/github.com/k3s-io/kine/hack/loadmap.py | 175 ++++++++++
 .../{rancher => k3s-io}/kine/main.go          |  27 +-
 .../github.com/k3s-io/kine/package/Dockerfile |   8 +
 .../kine/pkg/broadcaster/broadcaster.go       |   0
 .../kine/pkg/client/client.go                 |   2 +-
 .../kine/pkg/drivers/dqlite/dqlite.go         |  50 ++-
 .../kine/pkg/drivers/dqlite/no_dqlite.go      |  16 +
 .../kine/pkg/drivers/generic/generic.go       | 177 +++++-----
 .../k3s-io/kine/pkg/drivers/generic/tx.go     | 109 ++++++
 .../kine/pkg/drivers/mysql/mysql.go           |  76 +++--
 .../kine/pkg/drivers/pgsql/pgsql.go           |  62 +++-
 .../kine/pkg/drivers/sqlite/sqlite.go         |  46 ++-
 .../kine/pkg/drivers/sqlite/sqlite_nocgo.go   |  26 ++
 .../kine/pkg/endpoint/endpoint.go             |  28 +-
 .../kine/pkg/logstructured/logstructured.go   |  31 +-
 .../kine/pkg/logstructured/sqllog/sql.go      | 227 ++++++++-----
 .../kine/pkg/server/compact.go                |  13 +-
 .../kine/pkg/server/create.go                 |   0
 .../kine/pkg/server/delete.go                 |   0
 .../kine/pkg/server/get.go                    |   0
 .../kine/pkg/server/lease.go                  |   0
 .../kine/pkg/server/limited.go                |   0
 .../kine/pkg/server/list.go                   |   0
 .../kine/pkg/server/server.go                 |   0
 .../kine/pkg/server/types.go                  |   0
 .../kine/pkg/server/update.go                 |   0
 .../kine/pkg/server/watch.go                  |  10 +-
 .../kine/pkg/tls/config.go                    |   0
 vendor/github.com/k3s-io/kine/scripts/build   |  20 ++
 vendor/github.com/k3s-io/kine/scripts/ci      |  12 +
 vendor/github.com/k3s-io/kine/scripts/entry   |  11 +
 vendor/github.com/k3s-io/kine/scripts/package |  17 +
 vendor/github.com/k3s-io/kine/scripts/test    |  29 ++
 .../k3s-io/kine/scripts/test-helpers          | 320 ++++++++++++++++++
 .../github.com/k3s-io/kine/scripts/test-load  |  14 +
 .../k3s-io/kine/scripts/test-run-cockroachdb  |  37 ++
 .../k3s-io/kine/scripts/test-run-mysql        |  37 ++
 .../k3s-io/kine/scripts/test-run-postgres     |  36 ++
 .../k3s-io/kine/scripts/test-run-sqlite       |   9 +
 .../k3s-io/kine/scripts/test-runner           |  15 +
 .../github.com/k3s-io/kine/scripts/validate   |  19 ++
 .../k3s-io/kine/scripts/validate-ci           |  15 +
 vendor/github.com/k3s-io/kine/scripts/version |  34 ++
 .../kine/pkg/drivers/dqlite/no_dqlite.go      |  14 -
 .../kine/pkg/drivers/sqlite/sqlite_nocgo.go   |  26 --
 64 files changed, 1897 insertions(+), 349 deletions(-)
 create mode 100644 vendor/github.com/k3s-io/kine/.drone.yml
 rename vendor/github.com/{rancher => k3s-io}/kine/.gitignore (92%)
 create mode 100644 vendor/github.com/k3s-io/kine/.golangci.json
 rename vendor/github.com/{rancher => k3s-io}/kine/Dockerfile (100%)
 create mode 100644 vendor/github.com/k3s-io/kine/Dockerfile.dapper
 create mode 100644 vendor/github.com/k3s-io/kine/Dockerfile.test.dapper
 rename vendor/github.com/{rancher => k3s-io}/kine/LICENSE (99%)
 rename vendor/github.com/{rancher => k3s-io}/kine/README.md (55%)
 rename vendor/github.com/{rancher => k3s-io}/kine/examples/generate-certs.sh (99%)
 rename vendor/github.com/{rancher => k3s-io}/kine/examples/minimal.md (98%)
 rename vendor/github.com/{rancher => k3s-io}/kine/examples/mysql-ssl.cnf (100%)
 rename vendor/github.com/{rancher => k3s-io}/kine/go.mod (76%)
 rename vendor/github.com/{rancher => k3s-io}/kine/go.sum (99%)
 create mode 100755 vendor/github.com/k3s-io/kine/hack/histogram.py
 create mode 100755 vendor/github.com/k3s-io/kine/hack/loadmap.py
 rename vendor/github.com/{rancher => k3s-io}/kine/main.go (57%)
 create mode 100644 vendor/github.com/k3s-io/kine/package/Dockerfile
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/broadcaster/broadcaster.go (100%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/client/client.go (98%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/drivers/dqlite/dqlite.go (78%)
 create mode 100644 vendor/github.com/k3s-io/kine/pkg/drivers/dqlite/no_dqlite.go
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/drivers/generic/generic.go (70%)
 create mode 100644 vendor/github.com/k3s-io/kine/pkg/drivers/generic/tx.go
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/drivers/mysql/mysql.go (63%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/drivers/pgsql/pgsql.go (69%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/drivers/sqlite/sqlite.go (57%)
 create mode 100644 vendor/github.com/k3s-io/kine/pkg/drivers/sqlite/sqlite_nocgo.go
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/endpoint/endpoint.go (80%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/logstructured/logstructured.go (88%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/logstructured/sqllog/sql.go (60%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/server/compact.go (62%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/server/create.go (100%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/server/delete.go (100%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/server/get.go (100%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/server/lease.go (100%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/server/limited.go (100%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/server/list.go (100%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/server/server.go (100%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/server/types.go (100%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/server/update.go (100%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/server/watch.go (90%)
 rename vendor/github.com/{rancher => k3s-io}/kine/pkg/tls/config.go (100%)
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/build
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/ci
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/entry
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/package
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/test
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/test-helpers
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/test-load
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/test-run-cockroachdb
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/test-run-mysql
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/test-run-postgres
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/test-run-sqlite
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/test-runner
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/validate
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/validate-ci
 create mode 100755 vendor/github.com/k3s-io/kine/scripts/version
 delete mode 100644 vendor/github.com/rancher/kine/pkg/drivers/dqlite/no_dqlite.go
 delete mode 100644 vendor/github.com/rancher/kine/pkg/drivers/sqlite/sqlite_nocgo.go

diff --git a/cmd/kube-apiserver/app/server.go b/cmd/kube-apiserver/app/server.go
index 5fe121c1a16..0984d44befa 100644
--- a/cmd/kube-apiserver/app/server.go
+++ b/cmd/kube-apiserver/app/server.go
@@ -177,7 +177,8 @@ cluster's shared state through which all other components interact.`,
 func Run(completeOptions completedServerRunOptions, stopCh <-chan struct{}) error {
 	if completeOptions.Etcd.StorageConfig.Type == storagebackend.StorageTypeDqlite {
 		config := completeOptions.Etcd.StorageConfig
-		server, err := kvsqlserver.New(config.Dir)
+		os.Chdir(config.Dir)
+		server, err := kvsqlserver.New(config.Dir, "unix://kine.sock",true)
 		if err != nil {
 			return err
 		}
diff --git a/vendor/github.com/canonical/kvsql-dqlite/LICENSE b/vendor/github.com/canonical/kvsql-dqlite/LICENSE
index f433b1a53f5..e454a52586f 100644
--- a/vendor/github.com/canonical/kvsql-dqlite/LICENSE
+++ b/vendor/github.com/canonical/kvsql-dqlite/LICENSE
@@ -175,3 +175,4 @@
       of your accepting any such warranty or additional liability.
 
    END OF TERMS AND CONDITIONS
+
diff --git a/vendor/github.com/canonical/kvsql-dqlite/go.mod b/vendor/github.com/canonical/kvsql-dqlite/go.mod
index b3ae10d9fa8..c350638390e 100644
--- a/vendor/github.com/canonical/kvsql-dqlite/go.mod
+++ b/vendor/github.com/canonical/kvsql-dqlite/go.mod
@@ -15,7 +15,7 @@ require (
 	github.com/json-iterator/go v1.1.10 // indirect
 	github.com/lib/pq v1.7.0 // indirect
 	github.com/pkg/errors v0.9.1
-	github.com/rancher/kine v0.4.0
+	github.com/k3s-io/kine v0.6.0
 	github.com/sirupsen/logrus v1.6.0 // indirect
 	github.com/stretchr/testify v1.6.0
 	go.etcd.io/etcd v0.0.0-20191023171146-3cf2f69b5738
@@ -30,5 +30,3 @@ require (
 	k8s.io/apimachinery v0.17.0
 	k8s.io/apiserver v0.17.0
 )
-
-replace github.com/rancher/kine => github.com/canonical/kine v0.4.1-0.20200624100627-dd35576ecefb
diff --git a/vendor/github.com/canonical/kvsql-dqlite/go.sum b/vendor/github.com/canonical/kvsql-dqlite/go.sum
index 5e43efd93d7..451e5dc2520 100644
--- a/vendor/github.com/canonical/kvsql-dqlite/go.sum
+++ b/vendor/github.com/canonical/kvsql-dqlite/go.sum
@@ -225,6 +225,8 @@ github.com/json-iterator/go v1.1.10 h1:Kz6Cvnvv2wGdaG/V8yMvfkmNiXq9Ya2KUv4rouJJr
 github.com/json-iterator/go v1.1.10/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=
 github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=
 github.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=
+github.com/k3s-io/kine v0.6.0 h1:4l7wjgCxb2oD+7Hyf3xIhkGd/6s1sXpRFdQiyy+7Ki8=
+github.com/k3s-io/kine v0.6.0/go.mod h1:rzCs93+rQHZGOiewMd84PDrER92QeZ6eeHbWkfEy4+w=
 github.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=
 github.com/kisielk/errcheck v1.2.0/go.mod h1:/BMXB+zMLi60iA8Vv6Ksmxu/1UDYcXs4uQLJ+jE2L00=
 github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
@@ -240,6 +242,7 @@ github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
 github.com/lib/pq v1.1.1/go.mod h1:5WUZQaWbwv1U+lTReE5YruASi9Al49XbQIvNi/34Woo=
 github.com/lib/pq v1.7.0 h1:h93mCPfUSkaul3Ka/VG8uZdmW1uMHDGxzu0NWHuJmHY=
 github.com/lib/pq v1.7.0/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
+github.com/lib/pq v1.8.0/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
 github.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
 github.com/mailru/easyjson v0.0.0-20160728113105-d5b7844b561a/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
 github.com/mailru/easyjson v0.0.0-20180823135443-60711f1a8329/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
@@ -254,6 +257,7 @@ github.com/mattn/go-runewidth v0.0.3/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzp
 github.com/mattn/go-sqlite3 v1.10.0/go.mod h1:FPy6KqzDD04eiIsT53CuJW3U88zkxoIYsOqkbpncsNc=
 github.com/mattn/go-sqlite3 v1.14.0 h1:mLyGNKR8+Vv9CAU7PphKa2hkEqxxhn8i32J6FPj1/QA=
 github.com/mattn/go-sqlite3 v1.14.0/go.mod h1:JIl7NbARA7phWnGvh0LKTyg7S9BA+6gx71ShQilpsus=
+github.com/mattn/go-sqlite3 v1.14.4/go.mod h1:WVKg1VTActs4Qso6iwGbiFih2UIHo0ENGwNd0Lj+XmI=
 github.com/mattn/go-sqlite3 v2.0.3+incompatible h1:gXHsfypPkaMZrKbD5209QV9jbUTJKjyR5WD3HYQSd+U=
 github.com/mattn/go-sqlite3 v2.0.3+incompatible/go.mod h1:FPy6KqzDD04eiIsT53CuJW3U88zkxoIYsOqkbpncsNc=
 github.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=
diff --git a/vendor/github.com/canonical/kvsql-dqlite/server/server.go b/vendor/github.com/canonical/kvsql-dqlite/server/server.go
index f9dbbb19836..87f4155ae0d 100644
--- a/vendor/github.com/canonical/kvsql-dqlite/server/server.go
+++ b/vendor/github.com/canonical/kvsql-dqlite/server/server.go
@@ -3,6 +3,7 @@ package server
 import (
 	"context"
 	"fmt"
+	"github.com/k3s-io/kine/pkg/drivers/generic"
 	"io/ioutil"
 	"os"
 	"path/filepath"
@@ -13,8 +14,9 @@ import (
 	"github.com/canonical/go-dqlite/client"
 	"github.com/canonical/kvsql-dqlite/server/config"
 	"github.com/ghodss/yaml"
+	"github.com/k3s-io/kine/pkg/endpoint"
+	"github.com/k3s-io/kine/pkg/tls"
 	"github.com/pkg/errors"
-	"github.com/rancher/kine/pkg/endpoint"
 )
 
 // Server sets up a single dqlite node and serves the cluster management API.
@@ -25,8 +27,17 @@ type Server struct {
 	cancelKine context.CancelFunc
 }
 
-func New(dir string) (*Server, error) {
+var (
+	defaultKineEp = "tcp://127.0.0.1:12379"
+)
+
+func New(dir string, listen string, enableTls bool) (*Server, error) {
 	// Check if we're initializing a new node (i.e. there's an init.yaml).
+	// dir: the directory where data will be stored as well as where the init.yaml
+	//       and certificates should be found
+	// listen: kine listen endpoint could be a socket ("unix://<path>")
+	//         or network ep ("tcp://127.0.0.1:12345")
+	// enableTls: true if we should enable tls communication
 	cfg, err := config.Load(dir)
 	if err != nil {
 		return nil, err
@@ -67,9 +78,11 @@ func New(dir string) (*Server, error) {
 	}
 
 	options := []app.Option{
-		app.WithTLS(app.SimpleTLSConfig(cfg.KeyPair, cfg.Pool)),
 		app.WithFailureDomain(cfg.FailureDomain),
 	}
+	if enableTls {
+		options = append(options, app.WithTLS(app.SimpleTLSConfig(cfg.KeyPair, cfg.Pool)))
+	}
 
 	// Possibly initialize our ID, address and initial node store content.
 	if cfg.Init != nil {
@@ -93,8 +106,6 @@ func New(dir string) (*Server, error) {
 		return nil, err
 	}
 
-	socket := filepath.Join(dir, "kine.sock")
-
 	// Connect to a single peer that is the current machine
 	info := client.NodeInfo{}
 	infoFile := filepath.Join(dir, "info.yaml")
@@ -117,10 +128,33 @@ func New(dir string) (*Server, error) {
 	}
 
 	peers := localServerFile
+
+	ep := defaultKineEp
+	if listen != "" {
+		ep = listen
+	}
+
+	pool := generic.ConnectionPoolConfig{
+		MaxIdle:     5,
+		MaxOpen:     5,
+		MaxLifetime: 60 * time.Second,
+	}
 	config := endpoint.Config{
-		Listener: fmt.Sprintf("unix://%s", socket),
-		Endpoint: fmt.Sprintf("dqlite://k8s?peer-file=%s&driver-name=%s", peers, app.Driver()),
+		Listener:             ep,
+		Endpoint:             fmt.Sprintf("dqlite://k8s?peer-file=%s&driver-name=%s", peers, app.Driver()),
+		ConnectionPoolConfig: pool,
+	}
+
+	if enableTls {
+		crt := filepath.Join(dir, "cluster.crt")
+		key := filepath.Join(dir, "cluster.key")
+		kineTls := tls.Config{
+			CertFile: crt,
+			KeyFile: key,
+		}
+		config.Config = kineTls
 	}
+
 	kineCtx, cancelKine := context.WithCancel(context.Background())
 	if _, err := endpoint.Listen(kineCtx, config); err != nil {
 		return nil, errors.Wrap(err, "kine")
diff --git a/vendor/github.com/k3s-io/kine/.drone.yml b/vendor/github.com/k3s-io/kine/.drone.yml
new file mode 100644
index 00000000000..fbca6e13e09
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/.drone.yml
@@ -0,0 +1,261 @@
+---
+kind: pipeline
+type: docker
+name: amd64
+
+platform:
+  os: linux
+  arch: amd64
+
+steps:
+- name: build
+  image: rancher/dapper:v0.5.0
+  commands:
+  - dapper ci
+  environment:
+    ARCH: "${DRONE_STAGE_ARCH}"
+  volumes:
+  - name: docker
+    path: /var/run/docker.sock
+
+- name: test
+  image: rancher/dapper:v0.5.0
+  commands:
+  - dapper -f Dockerfile.test.dapper
+  environment:
+    ARCH: "${DRONE_STAGE_ARCH}"
+  volumes:
+  - name: docker
+    path: /var/run/docker.sock
+  when:
+    instance:
+    - drone-pr.k3s.io
+
+- name: github_binary_release
+  image: plugins/github-release
+  settings:
+    api_key:
+      from_secret: github_token
+    checksum:
+    - sha256
+    checksum_file: CHECKSUMsum-amd64.txt
+    checksum_flatten: true
+    files:
+    - dist/artifacts/*
+    prerelease: true
+  when:
+    event:
+    - tag
+    instance:
+    - drone-publish.k3s.io
+    ref:
+    - refs/head/master
+    - refs/tags/*
+
+- name: docker-publish
+  image: plugins/docker
+  settings:
+    build_args_from_env:
+    - ARCH
+    username:
+      from_secret: docker_username
+    password:
+      from_secret: docker_password
+    repo: rancher/kine
+    tag: "${DRONE_TAG}-${DRONE_STAGE_ARCH}"
+    dockerfile: package/Dockerfile
+  environment:
+    ARCH: "${DRONE_STAGE_ARCH}"
+    DOCKER_BUILDKIT: "1"
+  when:
+    event:
+    - tag
+    instance:
+    - drone-publish.k3s.io
+    ref:
+    - refs/head/master
+    - refs/tags/*
+
+volumes:
+- name: docker
+  host:
+    path: /var/run/docker.sock
+
+---
+kind: pipeline
+type: docker
+name: arm64
+
+platform:
+  os: linux
+  arch: arm64
+
+steps:
+- name: build
+  image: rancher/dapper:v0.5.0
+  commands:
+  - dapper ci
+  environment:
+    ARCH: "${DRONE_STAGE_ARCH}"
+  volumes:
+  - name: docker
+    path: /var/run/docker.sock
+
+- name: github_binary_release
+  image: plugins/github-release
+  settings:
+    api_key:
+      from_secret: github_token
+    checksum:
+    - sha256
+    checksum_file: CHECKSUMsum-arm64.txt
+    checksum_flatten: true
+    files:
+    - dist/artifacts/*
+    prerelease: true
+  when:
+    event:
+    - tag
+    instance:
+    - drone-publish.k3s.io
+    ref:
+    - refs/head/master
+    - refs/tags/*
+
+- name: docker-publish
+  image: plugins/docker
+  settings:
+    build_args_from_env:
+    - ARCH
+    username:
+      from_secret: docker_username
+    password:
+      from_secret: docker_password
+    repo: rancher/kine
+    tag: "${DRONE_TAG}-${DRONE_STAGE_ARCH}"
+    dockerfile: package/Dockerfile
+  environment:
+    ARCH: "${DRONE_STAGE_ARCH}"
+    DOCKER_BUILDKIT: "1"
+  when:
+    event:
+    - tag
+    instance:
+    - drone-publish.k3s.io
+    ref:
+    - refs/head/master
+    - refs/tags/*
+
+volumes:
+- name: docker
+  host:
+    path: /var/run/docker.sock
+
+---
+kind: pipeline
+type: docker
+name: arm
+
+platform:
+  os: linux
+  arch: arm
+
+steps:
+- name: build
+  image: rancher/dapper:v0.5.0
+  commands:
+  - dapper ci
+  environment:
+    ARCH: "${DRONE_STAGE_ARCH}"
+  volumes:
+  - name: docker
+    path: /var/run/docker.sock
+
+- name: github_binary_release
+  image: plugins/github-release
+  settings:
+    api_key:
+      from_secret: github_token
+    checksum:
+    - sha256
+    checksum_file: CHECKSUMsum-arm.txt
+    checksum_flatten: true
+    files:
+    - dist/artifacts/*
+    prerelease: true
+  when:
+    event:
+    - tag
+    instance:
+    - drone-publish.k3s.io
+    ref:
+    - refs/head/master
+    - refs/tags/*
+
+- name: docker-publish
+  image: plugins/docker
+  settings:
+    build_args_from_env:
+    - ARCH
+    username:
+      from_secret: docker_username
+    password:
+      from_secret: docker_password
+    repo: rancher/kine
+    tag: "${DRONE_TAG}-${DRONE_STAGE_ARCH}"
+    dockerfile: package/Dockerfile
+  environment:
+    ARCH: "${DRONE_STAGE_ARCH}"
+    DOCKER_BUILDKIT: "1"
+  when:
+    event:
+    - tag
+    instance:
+    - drone-publish.k3s.io
+    ref:
+    - refs/head/master
+    - refs/tags/*
+
+volumes:
+- name: docker
+  host:
+    path: /var/run/docker.sock
+
+---
+kind: pipeline
+type: docker
+name: manifest
+
+platform:
+  os: linux
+  arch: amd64
+
+steps:
+- name: manifest
+  image: plugins/manifest
+  settings:
+    username:
+      from_secret: docker_username
+    password:
+      from_secret: docker_password
+    platforms:
+    - linux/amd64
+    - linux/arm64
+    - linux/arm
+    target: "rancher/kine:${DRONE_TAG}"
+    template: "rancher/kine:${DRONE_TAG}-ARCH"
+  when:
+    event:
+    - tag
+    instance:
+    - drone-publish.k3s.io
+    ref:
+    - refs/head/master
+    - refs/tags/*
+
+depends_on:
+- amd64
+- arm64
+- arm
+
+...
diff --git a/vendor/github.com/rancher/kine/.gitignore b/vendor/github.com/k3s-io/kine/.gitignore
similarity index 92%
rename from vendor/github.com/rancher/kine/.gitignore
rename to vendor/github.com/k3s-io/kine/.gitignore
index 309948d8264..670f06ac30b 100644
--- a/vendor/github.com/rancher/kine/.gitignore
+++ b/vendor/github.com/k3s-io/kine/.gitignore
@@ -60,4 +60,11 @@ network_closure.sh
 *.pyc
 
 # Go vendor files
-vendor/
\ No newline at end of file
+vendor/
+
+# kine database file
+db/
+
+# build artifacts
+bin/
+dist/
diff --git a/vendor/github.com/k3s-io/kine/.golangci.json b/vendor/github.com/k3s-io/kine/.golangci.json
new file mode 100644
index 00000000000..14c6c29cf25
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/.golangci.json
@@ -0,0 +1,13 @@
+{
+	"linters": {
+		"disable-all": true,
+		"enable": [
+			"govet",
+			"golint",
+			"goimports"
+		]
+	},
+	"run": {
+		"deadline": "5m"
+	}
+}
diff --git a/vendor/github.com/rancher/kine/Dockerfile b/vendor/github.com/k3s-io/kine/Dockerfile
similarity index 100%
rename from vendor/github.com/rancher/kine/Dockerfile
rename to vendor/github.com/k3s-io/kine/Dockerfile
diff --git a/vendor/github.com/k3s-io/kine/Dockerfile.dapper b/vendor/github.com/k3s-io/kine/Dockerfile.dapper
new file mode 100644
index 00000000000..9b21aaa0c79
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/Dockerfile.dapper
@@ -0,0 +1,23 @@
+FROM golang:1.15-alpine3.12 AS dapper
+
+ARG ARCH=amd64
+
+RUN apk -U add bash coreutils git gcc musl-dev docker-cli vim less file curl wget ca-certificates
+RUN GO111MODULE=on GOPROXY=direct go get golang.org/x/lint/golint@83fdc39ff7b56453e3793356bcff3070b9b96445
+RUN GO111MODULE=on GOPROXY=direct go get golang.org/x/tools/cmd/goimports@gopls/v0.6.9
+RUN rm -rf /go/src /go/pkg
+
+RUN if [ "${ARCH}" == "amd64" ]; then \
+        curl -sL https://install.goreleaser.com/github.com/golangci/golangci-lint.sh | sh -s v1.38.0; \
+    fi
+
+ENV DAPPER_RUN_ARGS --privileged -v kine-cache:/go/src/github.com/k3s-io/kine/.cache
+ENV DAPPER_ENV ARCH REPO TAG DRONE_TAG IMAGE_NAME CROSS SKIP_VALIDATE
+ENV DAPPER_SOURCE /go/src/github.com/k3s-io/kine/
+ENV DAPPER_OUTPUT ./bin ./dist
+ENV DAPPER_DOCKER_SOCKET true
+ENV HOME ${DAPPER_SOURCE}
+WORKDIR ${DAPPER_SOURCE}
+
+ENTRYPOINT ["./scripts/entry"]
+CMD ["ci"]
diff --git a/vendor/github.com/k3s-io/kine/Dockerfile.test.dapper b/vendor/github.com/k3s-io/kine/Dockerfile.test.dapper
new file mode 100644
index 00000000000..498074d7400
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/Dockerfile.test.dapper
@@ -0,0 +1,16 @@
+FROM golang:1.15-alpine3.12 AS dapper
+
+ARG ARCH=amd64
+
+RUN apk -U add bash coreutils git gcc musl-dev docker-cli vim less file curl wget ca-certificates
+RUN apk -U add py3-pip && pip install kubernetes termplotlib
+
+ENV DAPPER_RUN_ARGS --privileged -v kine-cache:/go/src/github.com/k3s-io/kine/.cache
+ENV DAPPER_ENV ARCH REPO TAG DRONE_TAG IMAGE_NAME CROSS
+ENV DAPPER_SOURCE /go/src/github.com/k3s-io/kine/
+ENV DAPPER_DOCKER_SOCKET true
+ENV HOME ${DAPPER_SOURCE}
+WORKDIR ${DAPPER_SOURCE}
+
+ENTRYPOINT ["./scripts/entry"]
+CMD ["test"]
diff --git a/vendor/github.com/rancher/kine/LICENSE b/vendor/github.com/k3s-io/kine/LICENSE
similarity index 99%
rename from vendor/github.com/rancher/kine/LICENSE
rename to vendor/github.com/k3s-io/kine/LICENSE
index f433b1a53f5..e454a52586f 100644
--- a/vendor/github.com/rancher/kine/LICENSE
+++ b/vendor/github.com/k3s-io/kine/LICENSE
@@ -175,3 +175,4 @@
       of your accepting any such warranty or additional liability.
 
    END OF TERMS AND CONDITIONS
+
diff --git a/vendor/github.com/rancher/kine/README.md b/vendor/github.com/k3s-io/kine/README.md
similarity index 55%
rename from vendor/github.com/rancher/kine/README.md
rename to vendor/github.com/k3s-io/kine/README.md
index 7ead65bffd0..7c3db4928cd 100644
--- a/vendor/github.com/rancher/kine/README.md
+++ b/vendor/github.com/k3s-io/kine/README.md
@@ -1,8 +1,14 @@
-## Kine (Kine is not etcd)
+# Kine (Kine is not etcd)
+==========================
+
+_NOTE: this repository has been recently (2020-11-19) moved out of the github.com/rancher org to github.com/k3s-io
+supporting the [acceptance of K3s as a CNCF sandbox project](https://github.com/cncf/toc/pull/447)_.
+
+---
 
 Kine is an etcdshim that translates etcd API to sqlite, Postgres, Mysql, and dqlite
 
-### Features
+## Features
 - Can be ran standalone so any k8s (not just k3s) can use Kine
 - Implements a subset of etcdAPI (not usable at all for general purpose etcd)
 - Translates etcdTX calls into the desired API (Create, Update, Delete)
diff --git a/vendor/github.com/rancher/kine/examples/generate-certs.sh b/vendor/github.com/k3s-io/kine/examples/generate-certs.sh
similarity index 99%
rename from vendor/github.com/rancher/kine/examples/generate-certs.sh
rename to vendor/github.com/k3s-io/kine/examples/generate-certs.sh
index 33b9e516ac2..5b65e321833 100755
--- a/vendor/github.com/rancher/kine/examples/generate-certs.sh
+++ b/vendor/github.com/k3s-io/kine/examples/generate-certs.sh
@@ -9,3 +9,4 @@ openssl req -nodes -newkey rsa:2048 -keyout server.key -out server.csr -subj "/C
 
 # Sign the server cert
 openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt
+
diff --git a/vendor/github.com/rancher/kine/examples/minimal.md b/vendor/github.com/k3s-io/kine/examples/minimal.md
similarity index 98%
rename from vendor/github.com/rancher/kine/examples/minimal.md
rename to vendor/github.com/k3s-io/kine/examples/minimal.md
index 8666ee004d9..5d87ebe83ee 100644
--- a/vendor/github.com/rancher/kine/examples/minimal.md
+++ b/vendor/github.com/k3s-io/kine/examples/minimal.md
@@ -21,7 +21,7 @@ kine --endpoint "mysql://root:$PASSWORD@tcp(localhost:3306)/kine"  --ca-file ca.
 This will expose the mysql db as an etcd endpoint.
 
 ### Using with RKE
-Use the following RKE cluster.yml sample to boot up the cluster.
+Use the following RKE cluster.yml sample to boot up the cluster. 
 
 RKE supports using an external etcd endpoint.
 
@@ -48,7 +48,7 @@ services:
         - http://kine:2379
         ca_cert: |-
             -----BEGIN CERTIFICATE-----
-
+            
             -----END CERTIFICATE-----
         cert: |-
             -----BEGIN CERTIFICATE-----
@@ -110,6 +110,6 @@ etcd:
     keyFile: ./server.key
 ```
 
-The cluster can then be launched as
+The cluster can then be launched as 
 
 `kubeadm init --config kubeadm-master.cfg --ignore-preflight-errors ExternalEtcdVersion`
diff --git a/vendor/github.com/rancher/kine/examples/mysql-ssl.cnf b/vendor/github.com/k3s-io/kine/examples/mysql-ssl.cnf
similarity index 100%
rename from vendor/github.com/rancher/kine/examples/mysql-ssl.cnf
rename to vendor/github.com/k3s-io/kine/examples/mysql-ssl.cnf
diff --git a/vendor/github.com/rancher/kine/go.mod b/vendor/github.com/k3s-io/kine/go.mod
similarity index 76%
rename from vendor/github.com/rancher/kine/go.mod
rename to vendor/github.com/k3s-io/kine/go.mod
index d9a5ae9cb85..a8fda6a19e4 100644
--- a/vendor/github.com/rancher/kine/go.mod
+++ b/vendor/github.com/k3s-io/kine/go.mod
@@ -1,13 +1,13 @@
-module github.com/rancher/kine
+module github.com/k3s-io/kine
 
-go 1.12
+go 1.15
 
 require (
 	github.com/Rican7/retry v0.1.0
 	github.com/canonical/go-dqlite v1.5.1
 	github.com/go-sql-driver/mysql v1.4.1
-	github.com/lib/pq v1.1.1
-	github.com/mattn/go-sqlite3 v1.10.0
+	github.com/lib/pq v1.8.0
+	github.com/mattn/go-sqlite3 v1.14.4
 	github.com/pkg/errors v0.8.1
 	github.com/rancher/wrangler v0.4.0
 	github.com/sirupsen/logrus v1.4.2
diff --git a/vendor/github.com/rancher/kine/go.sum b/vendor/github.com/k3s-io/kine/go.sum
similarity index 99%
rename from vendor/github.com/rancher/kine/go.sum
rename to vendor/github.com/k3s-io/kine/go.sum
index 70effee0a5b..fa76f5f7a25 100644
--- a/vendor/github.com/rancher/kine/go.sum
+++ b/vendor/github.com/k3s-io/kine/go.sum
@@ -195,8 +195,8 @@ github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
 github.com/kr/pty v1.1.5/go.mod h1:9r2w37qlBe7rQ6e1fg1S/9xpWHSnaqNdHD3WcMdbPDA=
 github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
 github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
-github.com/lib/pq v1.1.1 h1:sJZmqHoEaY7f+NPP8pgLB/WxulyR3fewgCM2qaSlBb4=
-github.com/lib/pq v1.1.1/go.mod h1:5WUZQaWbwv1U+lTReE5YruASi9Al49XbQIvNi/34Woo=
+github.com/lib/pq v1.8.0 h1:9xohqzkUwzR4Ga4ivdTcawVS89YSDVxXMa3xJX3cGzg=
+github.com/lib/pq v1.8.0/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
 github.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
 github.com/mailru/easyjson v0.0.0-20160728113105-d5b7844b561a/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
 github.com/mailru/easyjson v0.0.0-20180823135443-60711f1a8329/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
@@ -207,8 +207,8 @@ github.com/mailru/easyjson v0.7.0/go.mod h1:KAzv3t3aY1NaHWoQz1+4F1ccyAH66Jk7yos7
 github.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=
 github.com/mattn/go-isatty v0.0.4/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=
 github.com/mattn/go-runewidth v0.0.2/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=
-github.com/mattn/go-sqlite3 v1.10.0 h1:jbhqpg7tQe4SupckyijYiy0mJJ/pRyHvXf7JdWK860o=
-github.com/mattn/go-sqlite3 v1.10.0/go.mod h1:FPy6KqzDD04eiIsT53CuJW3U88zkxoIYsOqkbpncsNc=
+github.com/mattn/go-sqlite3 v1.14.4 h1:4rQjbDxdu9fSgI/r3KN72G3c2goxknAqHHgPWWs8UlI=
+github.com/mattn/go-sqlite3 v1.14.4/go.mod h1:WVKg1VTActs4Qso6iwGbiFih2UIHo0ENGwNd0Lj+XmI=
 github.com/matttproud/golang_protobuf_extensions v1.0.1 h1:4hp9jkHxhMHkqkrB3Ix0jegS5sx/RkqARlsWZ6pIwiU=
 github.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=
 github.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=
diff --git a/vendor/github.com/k3s-io/kine/hack/histogram.py b/vendor/github.com/k3s-io/kine/hack/histogram.py
new file mode 100755
index 00000000000..fc77a189e1f
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/hack/histogram.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+
+# This is a terrible ugly hack of a script.
+
+import re
+import sys
+import logging
+import argparse
+import termplotlib as tpl
+
+from codecs import decode
+from kubernetes import client, config
+from kubernetes.client import Configuration
+
+METRIC = 'etcd_request_duration_seconds'
+
+
+def main(type, *args, **kwargs):
+    global v1
+
+    try:
+        config.load_kube_config()
+        version = client.VersionApi().get_code()
+        logging.info(f"Connected to {Configuration._default.host} - {version.git_version}")
+    except Exception as e:
+        logging.error(f"Kubernetes version check failed: {e}")
+        sys.exit(1)
+
+    res = client.ApiClient().call_api('/metrics', 'GET', _return_http_data_only=True, _preload_content=False)
+    operations = {}
+    prev_value = 0
+    for line in res.readlines():
+        match = re.search(r'(?P<metric>.+){(?P<labels>.+)} (?P<value>\d+)', decode(line))
+        if match:
+            labels = {}
+            metric = match.group('metric')
+            value = int(match.group('value'))
+
+            if not metric.startswith(METRIC):
+                continue
+
+            for part in match.group('labels').split(','):
+                k, v = part.split('=')
+                labels[k] = v.strip('"')
+
+            if not labels.get('type', '').endswith(type):
+                continue
+
+            if labels['operation'] not in operations:
+                operations[labels['operation']] = {'counts': [], 'buckets': [], 'type': labels['type']}
+                prev_value = 0
+
+            if metric.endswith('_bucket'):
+                operations[labels['operation']]['counts'].append(value - prev_value)
+                operations[labels['operation']]['buckets'].append(labels['le'])
+                prev_value = value
+            elif metric.endswith('_sum'):
+                operations[labels['operation']]['sum'] = value
+            elif metric.endswith('_count'):
+                operations[labels['operation']]['count'] = value
+
+    for operation, stats in operations.items():
+        print(f"\n{stats['sum'] / stats['count']:.3f}  average etcd request duration (seconds): {operation} {stats['type']}")
+        fig = tpl.figure()
+        fig.barh(stats['counts'], stats['buckets'], max_width=50)
+        fig.show()
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--type', '-t', type=str, required=False, default='core.ConfigMap')
+    parser.add_argument('--log-level', '-l', type=str, required=False, default='INFO')
+    args = parser.parse_args()
+
+    try:
+        logging.basicConfig(level=args.log_level, format='[%(process)d]\t%(levelname).1s %(message)s')
+        main(**vars(args))
+    except KeyboardInterrupt:
+        pass
+    except Exception:
+        logging.exception('Unhandled exception')
diff --git a/vendor/github.com/k3s-io/kine/hack/loadmap.py b/vendor/github.com/k3s-io/kine/hack/loadmap.py
new file mode 100755
index 00000000000..c4758fbd0a0
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/hack/loadmap.py
@@ -0,0 +1,175 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+
+# This is a terrible ugly hack of a script.
+
+import sys
+import logging
+import argparse
+import random
+import string
+
+from kubernetes import client, config
+from kubernetes.client import Configuration
+
+namespace = "load-test"
+configmaps = dict()
+
+
+def main(rounds, *args, **kwargs):
+    global v1
+
+    try:
+        config.load_kube_config()
+        version = client.VersionApi().get_code()
+        logging.info(f"Connected to {Configuration._default.host} - {version.git_version}")
+    except Exception as e:
+        logging.error(f"Kubernetes version check failed: {e}")
+        sys.exit(1)
+
+    v1 = client.CoreV1Api()
+    ns = client.V1Namespace(
+            metadata=client.V1ObjectMeta(
+                name=namespace))
+
+    try:
+        v1.create_namespace(ns)
+    except client.exceptions.ApiException as e:
+        if e.status == 409:
+            pass
+        else:
+            raise e
+
+    for _ in range(rounds):
+        i = random.randint(0, 9)
+        if i in [0, 1]:
+            create_configmap()
+        elif i in [2, 3, 4, 5, 6]:
+            update_configmap()
+        elif i in [7, 8]:
+            delete_configmap()
+        else:
+            list_configmaps()
+
+
+def update_or_merge_configmap(cm):
+    while True:
+        try:
+            logging.debug(f"Updating {cm.metadata.name} rev={cm.metadata.resource_version}")
+            return v1.replace_namespaced_config_map(name=cm.metadata.name, namespace=namespace, body=cm)
+        except client.exceptions.ApiException as e:
+            logging.debug(f"\tError: {e.status}")
+            if e.status == 409 and 'StorageError: invalid object' in e.body:
+                logging.debug("\tCreating and merging...")
+                cm1 = create_or_get_configmap(cm)
+                if not cm1.data:
+                    cm1.data = dict()
+                cm1.data.update(cm.data)
+                cm = cm1
+            elif e.status == 409:
+                logging.debug("\tReading and merging...")
+                try:
+                    cm1 = v1.read_namespaced_config_map(name=cm.metadata.name, namespace=namespace)
+                    if not cm1.data:
+                        cm1.data = dict()
+                    cm1.data.update(cm.data)
+                    cm = cm1
+                except client.exceptions.ApiException as e1:
+                    if e1.status == 404:
+                        pass
+                    else:
+                        raise e1
+            else:
+                raise e
+
+
+def create_or_get_configmap(cm):
+    cm.metadata.resource_version = ''
+    while True:
+        try:
+            logging.debug(f"Creating {cm.metadata.name}")
+            return v1.create_namespaced_config_map(namespace=namespace, body=cm)
+        except client.exceptions.ApiException as e:
+            logging.debug(f"\tError: {e.status}")
+            if e.status == 409:
+                logging.debug("\tReading existing...")
+                try:
+                    return v1.read_namespaced_config_map(name=cm.metadata.name, namespace=namespace)
+                except client.exceptions.ApiException as e1:
+                    if e1.status == 404:
+                        pass
+                    else:
+                        raise e1
+            else:
+                raise e
+
+
+def try_delete_configmap(cm):
+    try:
+        logging.debug(f"Deleting {cm.metadata.name} rev={cm.metadata.resource_version}")
+        options = client.V1DeleteOptions(
+                    preconditions=client.V1Preconditions(
+                        resource_version=cm.metadata.resource_version))
+        v1.delete_namespaced_config_map(name=cm.metadata.name, namespace=namespace, body=options)
+        return True
+    except client.exceptions.ApiException as e:
+        logging.debug(f"\tError: {e.status}")
+        if e.status == 404:
+            return True
+        elif e.status == 409:
+            return False
+        else:
+            raise e
+
+
+def create_configmap():
+    i = random.randint(0, 99)
+    cm = client.V1ConfigMap(
+            metadata=client.V1ObjectMeta(
+                name=f"test-{i:02}"))
+    configmaps[i] = create_or_get_configmap(cm)
+
+
+def update_configmap():
+    if not configmaps:
+        return
+    i = random.choice(list(configmaps.keys()))
+    j = random.randint(0, 99)
+    k = random.randint(1, 16) * 256
+    cm = configmaps[i]
+    if not cm.data:
+        cm.data = dict()
+    cm.data[f"key-{j:02}"] = ''.join(random.choices(string.printable, k=k))
+    configmaps[i] = update_or_merge_configmap(cm)
+
+
+def delete_configmap():
+    if not configmaps:
+        return
+    i = random.choice(list(configmaps.keys()))
+    cm = configmaps[i]
+    if try_delete_configmap(cm):
+        del configmaps[i]
+
+
+def list_configmaps():
+    if not configmaps:
+        return
+    cml = v1.list_namespaced_config_map(namespace=namespace)
+    for cm in cml.items:
+        configmaps[cm.metadata.name] = cm
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--rounds', '-r', type=int, required=False, default=5000)
+    parser.add_argument('--log-level', '-l', type=str, required=False, default='INFO')
+    args = parser.parse_args()
+
+    try:
+        logging.basicConfig(level=args.log_level, format='[%(process)d]\t%(levelname).1s %(message)s')
+        main(**vars(args))
+    except KeyboardInterrupt:
+        pass
+    except Exception:
+        logging.exception('Unhandled exception')
diff --git a/vendor/github.com/rancher/kine/main.go b/vendor/github.com/k3s-io/kine/main.go
similarity index 57%
rename from vendor/github.com/rancher/kine/main.go
rename to vendor/github.com/k3s-io/kine/main.go
index 7fc1aeb3673..c9bd8195663 100644
--- a/vendor/github.com/rancher/kine/main.go
+++ b/vendor/github.com/k3s-io/kine/main.go
@@ -2,9 +2,10 @@ package main
 
 import (
 	"context"
+	"errors"
 	"os"
 
-	"github.com/rancher/kine/pkg/endpoint"
+	"github.com/k3s-io/kine/pkg/endpoint"
 	"github.com/rancher/wrangler/pkg/signals"
 	"github.com/sirupsen/logrus"
 	"github.com/urfave/cli"
@@ -40,6 +41,24 @@ func main() {
 			Usage:       "Certificate for DB connection",
 			Destination: &config.CertFile,
 		},
+		cli.IntFlag{
+			Name:        "datastore-max-idle-connections",
+			Usage:       "Maximum number of idle connections retained by datastore. If value = 0, the system default will be used. If value < 0, idle connections will not be reused.",
+			Destination: &config.ConnectionPoolConfig.MaxIdle,
+			Value:       0,
+		},
+		cli.IntFlag{
+			Name:        "datastore-max-open-connections",
+			Usage:       "Maximum number of open connections used by datastore. If value <= 0, then there is no limit",
+			Destination: &config.ConnectionPoolConfig.MaxOpen,
+			Value:       0,
+		},
+		cli.DurationFlag{
+			Name:        "datastore-connection-max-lifetime",
+			Usage:       "Maximum amount of time a connection may be reused. If value <= 0, then there is no limit.",
+			Destination: &config.ConnectionPoolConfig.MaxLifetime,
+			Value:       0,
+		},
 		cli.StringFlag{
 			Name:        "key-file",
 			Usage:       "Key file for DB connection",
@@ -50,13 +69,15 @@ func main() {
 	app.Action = run
 
 	if err := app.Run(os.Args); err != nil {
-		logrus.Fatal(err)
+		if !errors.Is(err, context.Canceled) {
+			logrus.Fatal(err)
+		}
 	}
 }
 
 func run(c *cli.Context) error {
 	if c.Bool("debug") {
-		logrus.SetLevel(logrus.DebugLevel)
+		logrus.SetLevel(logrus.TraceLevel)
 	}
 	ctx := signals.SetupSignalHandler(context.Background())
 	_, err := endpoint.Listen(ctx, config)
diff --git a/vendor/github.com/k3s-io/kine/package/Dockerfile b/vendor/github.com/k3s-io/kine/package/Dockerfile
new file mode 100644
index 00000000000..5e99fd59879
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/package/Dockerfile
@@ -0,0 +1,8 @@
+FROM alpine:3.12
+ARG ARCH=amd64
+COPY dist/artifacts/kine-${ARCH} /bin/kine
+RUN mkdir /db && chown nobody /db
+VOLUME /db
+EXPOSE 2379/tcp
+USER nobody
+ENTRYPOINT ["/bin/kine"]
diff --git a/vendor/github.com/rancher/kine/pkg/broadcaster/broadcaster.go b/vendor/github.com/k3s-io/kine/pkg/broadcaster/broadcaster.go
similarity index 100%
rename from vendor/github.com/rancher/kine/pkg/broadcaster/broadcaster.go
rename to vendor/github.com/k3s-io/kine/pkg/broadcaster/broadcaster.go
diff --git a/vendor/github.com/rancher/kine/pkg/client/client.go b/vendor/github.com/k3s-io/kine/pkg/client/client.go
similarity index 98%
rename from vendor/github.com/rancher/kine/pkg/client/client.go
rename to vendor/github.com/k3s-io/kine/pkg/client/client.go
index 8dfc8ae70d8..db17e8441cf 100644
--- a/vendor/github.com/rancher/kine/pkg/client/client.go
+++ b/vendor/github.com/k3s-io/kine/pkg/client/client.go
@@ -6,7 +6,7 @@ import (
 	"fmt"
 	"time"
 
-	"github.com/rancher/kine/pkg/endpoint"
+	"github.com/k3s-io/kine/pkg/endpoint"
 	"go.etcd.io/etcd/clientv3"
 )
 
diff --git a/vendor/github.com/rancher/kine/pkg/drivers/dqlite/dqlite.go b/vendor/github.com/k3s-io/kine/pkg/drivers/dqlite/dqlite.go
similarity index 78%
rename from vendor/github.com/rancher/kine/pkg/drivers/dqlite/dqlite.go
rename to vendor/github.com/k3s-io/kine/pkg/drivers/dqlite/dqlite.go
index 9cb5f740091..08fbd2c7ba8 100644
--- a/vendor/github.com/rancher/kine/pkg/drivers/dqlite/dqlite.go
+++ b/vendor/github.com/k3s-io/kine/pkg/drivers/dqlite/dqlite.go
@@ -4,19 +4,25 @@ package dqlite
 
 import (
 	"context"
+	crypto_tls "crypto/tls"
+	"crypto/x509"
 	"database/sql"
 	"fmt"
+	"io/ioutil"
 	"net/url"
 	"os"
 	"strconv"
 	"strings"
 
 	"github.com/canonical/go-dqlite"
+	"github.com/canonical/go-dqlite/app"
 	"github.com/canonical/go-dqlite/client"
 	"github.com/canonical/go-dqlite/driver"
+	"github.com/k3s-io/kine/pkg/drivers/generic"
+	"github.com/k3s-io/kine/pkg/drivers/sqlite"
+	"github.com/k3s-io/kine/pkg/server"
+	"github.com/k3s-io/kine/pkg/tls"
 	"github.com/pkg/errors"
-	"github.com/rancher/kine/pkg/drivers/sqlite"
-	"github.com/rancher/kine/pkg/server"
 	"github.com/sirupsen/logrus"
 )
 
@@ -67,7 +73,7 @@ outer:
 	return nil
 }
 
-func New(ctx context.Context, datasourceName string) (server.Backend, error) {
+func New(ctx context.Context, datasourceName string, tlsInfo tls.Config, connPoolConfig generic.ConnectionPoolConfig) (server.Backend, error) {
 	opts, err := parseOpts(datasourceName)
 	if err != nil {
 		return nil, err
@@ -89,17 +95,21 @@ func New(ctx context.Context, datasourceName string) (server.Backend, error) {
 
 	if opts.driverName == "" {
 		opts.driverName = "dqlite"
+		dial, err := getDialer(tlsInfo)
+		if err != nil {
+			return nil, err
+		}
 		d, err := driver.New(nodeStore,
 			driver.WithLogFunc(Logger),
 			driver.WithContext(ctx),
-			driver.WithDialFunc(Dialer))
+			dial)
 		if err != nil {
 			return nil, errors.Wrap(err, "new dqlite driver")
 		}
 		sql.Register(opts.driverName, d)
 	}
 
-	backend, generic, err := sqlite.NewVariant(ctx, opts.driverName, opts.dsn)
+	backend, generic, err := sqlite.NewVariant(ctx, opts.driverName, opts.dsn, connPoolConfig)
 	if err != nil {
 		return nil, errors.Wrap(err, "sqlite client")
 	}
@@ -124,6 +134,33 @@ func New(ctx context.Context, datasourceName string) (server.Backend, error) {
 	return backend, nil
 }
 
+func getDialer(tlsInfo tls.Config) (driver.Option, error) {
+	dial := client.DefaultDialFunc
+	if (tlsInfo.CertFile != "" && tlsInfo.KeyFile == "") || (tlsInfo.KeyFile != "" && tlsInfo.CertFile == "") {
+		return nil, errors.New("both TLS certificate and key must be given")
+	}
+	if tlsInfo.CertFile != "" {
+		cert, err := crypto_tls.LoadX509KeyPair(tlsInfo.CertFile, tlsInfo.KeyFile)
+		if err != nil {
+			return nil, errors.New("bad certificate pair")
+		}
+
+		data, err := ioutil.ReadFile(tlsInfo.CertFile)
+		if err != nil {
+			return nil, errors.New("could not read certificate")
+		}
+
+		pool := x509.NewCertPool()
+		if !pool.AppendCertsFromPEM(data) {
+			return nil, errors.New("bad certificate")
+		}
+
+		config := app.SimpleDialTLSConfig(cert, pool)
+		dial = client.DialFuncWithTLS(dial, config)
+	}
+	return driver.WithDialFunc(dial), nil
+}
+
 func migrate(ctx context.Context, newDB *sql.DB) (exitErr error) {
 	row := newDB.QueryRowContext(ctx, "SELECT COUNT(*) FROM kine")
 	var count int64
@@ -232,9 +269,6 @@ func parseOpts(dsn string) (opts, error) {
 		case "peer-file":
 			result.peerFile = vs[0]
 			delete(values, k)
-		case "driver-name":
-			result.driverName = vs[0]
-			delete(values, k)
 		}
 	}
 
diff --git a/vendor/github.com/k3s-io/kine/pkg/drivers/dqlite/no_dqlite.go b/vendor/github.com/k3s-io/kine/pkg/drivers/dqlite/no_dqlite.go
new file mode 100644
index 00000000000..61d9ecf5080
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/pkg/drivers/dqlite/no_dqlite.go
@@ -0,0 +1,16 @@
+// +build !dqlite
+
+package dqlite
+
+import (
+	"context"
+	"errors"
+
+	"github.com/k3s-io/kine/pkg/drivers/generic"
+	"github.com/k3s-io/kine/pkg/server"
+	"github.com/k3s-io/kine/pkg/tls"
+)
+
+func New(ctx context.Context, datasourceName string, tlsInfo tls.Config, connPoolConfig generic.ConnectionPoolConfig) (server.Backend, error) {
+	return nil, errors.New(`this binary is built without dqlite support, compile with "-tags dqlite"`)
+}
diff --git a/vendor/github.com/rancher/kine/pkg/drivers/generic/generic.go b/vendor/github.com/k3s-io/kine/pkg/drivers/generic/generic.go
similarity index 70%
rename from vendor/github.com/rancher/kine/pkg/drivers/generic/generic.go
rename to vendor/github.com/k3s-io/kine/pkg/drivers/generic/generic.go
index d6513271aa2..46a0c1456cd 100644
--- a/vendor/github.com/rancher/kine/pkg/drivers/generic/generic.go
+++ b/vendor/github.com/k3s-io/kine/pkg/drivers/generic/generic.go
@@ -10,38 +10,42 @@ import (
 	"sync"
 	"time"
 
-	"github.com/Rican7/retry/jitter"
+	"github.com/Rican7/retry/backoff"
+	"github.com/Rican7/retry/strategy"
 	"github.com/sirupsen/logrus"
 )
 
+const (
+	defaultMaxIdleConns = 2 // copied from database/sql
+)
+
 var (
-	columns = "kv.id as theid, kv.name, kv.created, kv.deleted, kv.create_revision, kv.prev_revision, kv.lease, kv.value, kv.old_value"
+	columns = "kv.id AS theid, kv.name, kv.created, kv.deleted, kv.create_revision, kv.prev_revision, kv.lease, kv.value, kv.old_value"
 	revSQL  = `
-		SELECT rkv.id
-		FROM kine rkv
-		ORDER BY rkv.id
-		DESC LIMIT 1`
+		SELECT MAX(rkv.id) AS id
+		FROM kine AS rkv`
 
 	compactRevSQL = `
-		SELECT crkv.prev_revision
-		FROM kine crkv
-		WHERE crkv.name = 'compact_rev_key'
-		ORDER BY crkv.id DESC LIMIT 1`
+		SELECT MAX(crkv.prev_revision) AS prev_revision
+		FROM kine AS crkv
+		WHERE crkv.name = 'compact_rev_key'`
 
 	idOfKey = `
-		AND mkv.id <= ? AND mkv.id > (
-			SELECT ikv.id
-			FROM kine ikv
+		AND
+		mkv.id <= ? AND
+		mkv.id > (
+			SELECT MAX(ikv.id) AS id
+			FROM kine AS ikv
 			WHERE
 				ikv.name = ? AND
-				ikv.id <= ?
-			ORDER BY ikv.id DESC LIMIT 1)`
+				ikv.id <= ?)`
 
-	listSQL = fmt.Sprintf(`SELECT (%s), (%s), %s
-		FROM kine kv
+	listSQL = fmt.Sprintf(`
+		SELECT (%s), (%s), %s
+		FROM kine AS kv
 		JOIN (
-			SELECT MAX(mkv.id) as id
-			FROM kine mkv
+			SELECT MAX(mkv.id) AS id
+			FROM kine AS mkv
 			WHERE
 				mkv.name LIKE ?
 				%%s
@@ -63,6 +67,12 @@ func (s Stripped) String() string {
 type ErrRetry func(error) bool
 type TranslateErr func(error) error
 
+type ConnectionPoolConfig struct {
+	MaxIdle     int           // zero means defaultMaxIdleConns; negative means 0
+	MaxOpen     int           // <= 0 means unlimited
+	MaxLifetime time.Duration // maximum amount of time a connection may be reused
+}
+
 type Generic struct {
 	sync.Mutex
 
@@ -77,6 +87,7 @@ type Generic struct {
 	CountSQL              string
 	AfterSQL              string
 	DeleteSQL             string
+	CompactSQL            string
 	UpdateCompactSQL      string
 	InsertSQL             string
 	FillSQL               string
@@ -85,12 +96,6 @@ type Generic struct {
 	TranslateErr          TranslateErr
 }
 
-func configureConnectionPooling(db *sql.DB) {
-	db.SetMaxIdleConns(5)
-	db.SetMaxOpenConns(5)
-	db.SetConnMaxLifetime(60 * time.Second)
-}
-
 func q(sql, param string, numbered bool) string {
 	if param == "?" && !numbered {
 		return sql
@@ -129,6 +134,20 @@ func (d *Generic) Migrate(ctx context.Context) {
 	}
 }
 
+func configureConnectionPooling(connPoolConfig ConnectionPoolConfig, db *sql.DB, driverName string) {
+	// behavior copied from database/sql - zero means defaultMaxIdleConns; negative means 0
+	if connPoolConfig.MaxIdle < 0 {
+		connPoolConfig.MaxIdle = 0
+	} else if connPoolConfig.MaxIdle == 0 {
+		connPoolConfig.MaxIdle = defaultMaxIdleConns
+	}
+
+	logrus.Infof("Configuring %s database connection pooling: maxIdleConns=%d, maxOpenConns=%d, connMaxLifetime=%s", driverName, connPoolConfig.MaxIdle, connPoolConfig.MaxOpen, connPoolConfig.MaxLifetime)
+	db.SetMaxIdleConns(connPoolConfig.MaxIdle)
+	db.SetMaxOpenConns(connPoolConfig.MaxOpen)
+	db.SetConnMaxLifetime(connPoolConfig.MaxLifetime)
+}
+
 func openAndTest(driverName, dataSourceName string) (*sql.DB, error) {
 	db, err := sql.Open(driverName, dataSourceName)
 	if err != nil {
@@ -145,7 +164,7 @@ func openAndTest(driverName, dataSourceName string) (*sql.DB, error) {
 	return db, nil
 }
 
-func Open(ctx context.Context, driverName, dataSourceName string, paramCharacter string, numbered bool) (*Generic, error) {
+func Open(ctx context.Context, driverName, dataSourceName string, connPoolConfig ConnectionPoolConfig, paramCharacter string, numbered bool) (*Generic, error) {
 	var (
 		db  *sql.DB
 		err error
@@ -165,7 +184,7 @@ func Open(ctx context.Context, driverName, dataSourceName string, paramCharacter
 		}
 	}
 
-	configureConnectionPooling(db)
+	configureConnectionPooling(connPoolConfig, db, driverName)
 
 	return &Generic{
 		DB: db,
@@ -173,7 +192,7 @@ func Open(ctx context.Context, driverName, dataSourceName string, paramCharacter
 		GetRevisionSQL: q(fmt.Sprintf(`
 			SELECT
 			0, 0, %s
-			FROM kine kv
+			FROM kine AS kv
 			WHERE kv.id = ?`, columns), paramCharacter, numbered),
 
 		GetCurrentSQL:        q(fmt.Sprintf(listSQL, ""), paramCharacter, numbered),
@@ -188,15 +207,15 @@ func Open(ctx context.Context, driverName, dataSourceName string, paramCharacter
 
 		AfterSQL: q(fmt.Sprintf(`
 			SELECT (%s), (%s), %s
-			FROM kine kv
+			FROM kine AS kv
 			WHERE
 				kv.name LIKE ? AND
 				kv.id > ?
 			ORDER BY kv.id ASC`, revSQL, compactRevSQL, columns), paramCharacter, numbered),
 
 		DeleteSQL: q(`
-			DELETE FROM kine
-			WHERE id = ?`, paramCharacter, numbered),
+			DELETE FROM kine AS kv
+			WHERE kv.id = ?`, paramCharacter, numbered),
 
 		UpdateCompactSQL: q(`
 			UPDATE kine
@@ -215,73 +234,51 @@ func Open(ctx context.Context, driverName, dataSourceName string, paramCharacter
 }
 
 func (d *Generic) query(ctx context.Context, sql string, args ...interface{}) (rows *sql.Rows, err error) {
-	i := uint(0)
-	defer func() {
-		if err != nil {
-			err = fmt.Errorf("query (try: %d): %w", i, err)
-		}
-	}()
-	for ; i < 500; i++ {
-		if i > 2 {
-			logrus.Debugf("QUERY (try: %d) %v : %s", i, args, Stripped(sql))
-		} else {
-			logrus.Tracef("QUERY (try: %d) %v : %s", i, args, Stripped(sql))
-		}
+	wait := strategy.Backoff(backoff.Linear(6 * time.Millisecond))
+	for i := uint(0); i < 20; i++ {
+		logrus.Tracef("QUERY %v : %s", args, Stripped(sql))
 		rows, err = d.DB.QueryContext(ctx, sql, args...)
 		if err != nil && d.Retry != nil && d.Retry(err) {
-			time.Sleep(jitter.Deviation(nil, 0.3)(2 * time.Millisecond))
+			wait(i)
 			continue
 		}
 		return rows, err
 	}
-	return
+
+	return nil, err
 }
 
-func (d *Generic) queryInt64(ctx context.Context, sql string, args ...interface{}) (n int64, err error) {
-	i := uint(0)
-	defer func() {
-		if err != nil {
-			err = fmt.Errorf("query int64 (try: %d): %w", i, err)
-		}
-	}()
-	for ; i < 500; i++ {
-		if i > 2 {
-			logrus.Debugf("QUERY INT64 (try: %d) %v : %s", i, args, Stripped(sql))
-		} else {
-			logrus.Tracef("QUERY INT64 (try: %d) %v : %s", i, args, Stripped(sql))
+func (d *Generic) queryInt64(ctx context.Context, query string, args ...interface{}) (res int64, err error) {
+	wait := strategy.Backoff(backoff.Linear(6 * time.Millisecond))
+	for i := uint(0); i < 20; i++ {
+		logrus.Tracef("QUERY ROW %v : %s", args, Stripped(query))
+		row := d.DB.QueryRowContext(ctx, query, args...)
+		err = row.Scan(&res)
+		if err == sql.ErrNoRows {
+			return 0, err
 		}
-		row := d.DB.QueryRowContext(ctx, sql, args...)
-		err = row.Scan(&n)
 		if err != nil && d.Retry != nil && d.Retry(err) {
-			time.Sleep(jitter.Deviation(nil, 0.3)(2 * time.Millisecond))
+			wait(i)
 			continue
 		}
-		return n, err
+		return res, err
 	}
-	return
+
+	return 0, err
 }
 
 func (d *Generic) execute(ctx context.Context, sql string, args ...interface{}) (result sql.Result, err error) {
-	i := uint(0)
-	defer func() {
-		if err != nil {
-			err = fmt.Errorf("exec (try: %d): %w", i, err)
-		}
-	}()
 	if d.LockWrites {
 		d.Lock()
 		defer d.Unlock()
 	}
 
-	for ; i < 500; i++ {
-		if i > 2 {
-			logrus.Debugf("EXEC (try: %d) %v : %s", i, args, Stripped(sql))
-		} else {
-			logrus.Tracef("EXEC (try: %d) %v : %s", i, args, Stripped(sql))
-		}
+	wait := strategy.Backoff(backoff.Linear(6 * time.Millisecond))
+	for i := uint(0); i < 20; i++ {
+		logrus.Tracef("EXEC (try: %d) %v : %s", i, args, Stripped(sql))
 		result, err = d.DB.ExecContext(ctx, sql, args...)
 		if err != nil && d.Retry != nil && d.Retry(err) {
-			time.Sleep(jitter.Deviation(nil, 0.3)(2 * time.Millisecond))
+			wait(i)
 			continue
 		}
 		return result, err
@@ -298,15 +295,26 @@ func (d *Generic) GetCompactRevision(ctx context.Context) (int64, error) {
 }
 
 func (d *Generic) SetCompactRevision(ctx context.Context, revision int64) error {
+	logrus.Tracef("SETCOMPACTREVISION %v", revision)
 	_, err := d.execute(ctx, d.UpdateCompactSQL, revision)
 	return err
 }
 
+func (d *Generic) Compact(ctx context.Context, revision int64) (int64, error) {
+	logrus.Tracef("COMPACT %v", revision)
+	res, err := d.execute(ctx, d.CompactSQL, revision, revision)
+	if err != nil {
+		return 0, err
+	}
+	return res.RowsAffected()
+}
+
 func (d *Generic) GetRevision(ctx context.Context, revision int64) (*sql.Rows, error) {
 	return d.query(ctx, d.GetRevisionSQL, revision)
 }
 
 func (d *Generic) DeleteRevision(ctx context.Context, revision int64) error {
+	logrus.Tracef("DELETEREVISION %v", revision)
 	_, err := d.execute(ctx, d.DeleteSQL, revision)
 	return err
 }
@@ -332,6 +340,7 @@ func (d *Generic) List(ctx context.Context, prefix, startKey string, limit, revi
 	if limit > 0 {
 		sql = fmt.Sprintf("%s LIMIT %d", sql, limit)
 	}
+	logrus.Tracef("In List sql -> %s , prefix -> %s, revision -> %d, startKey -> %s, revision -> %d", sql, prefix, revision, startKey, revision)
 	return d.query(ctx, sql, prefix, revision, startKey, revision, includeDeleted)
 }
 
@@ -340,26 +349,19 @@ func (d *Generic) Count(ctx context.Context, prefix string) (int64, int64, error
 		rev sql.NullInt64
 		id  int64
 		err error
-		i   uint
 	)
 
-	for ; i < 500; i++ {
-		if i > 0 {
-			logrus.Debugf("COUNT (try: %d) : %s", i, prefix)
-		} else {
-			logrus.Tracef("COUNT (try: %d) : %s", i, prefix)
-		}
+	wait := strategy.Backoff(backoff.Linear(6 * time.Millisecond))
+	for i := uint(0); i < 20; i++ {
+		logrus.Tracef("COUNT (try: %d) : %s", i, prefix)
 		row := d.DB.QueryRowContext(ctx, d.CountSQL, prefix, false)
 		err = row.Scan(&rev, &id)
 		if err != nil && d.Retry != nil && d.Retry(err) {
-			time.Sleep(jitter.Deviation(nil, 0.3)(2 * time.Millisecond))
+			wait(i)
 			continue
 		}
 		break
 	}
-	if err != nil {
-		err = fmt.Errorf("count %s (try: %d): %w", prefix, i, err)
-	}
 	return rev.Int64, id, err
 }
 
@@ -414,6 +416,5 @@ func (d *Generic) Insert(ctx context.Context, key string, create, delete bool, c
 		return row.LastInsertId()
 	}
 
-	id, err = d.queryInt64(ctx, d.InsertSQL, key, cVal, dVal, createRevision, previousRevision, ttl, value, prevValue)
-	return id, err
+	return d.queryInt64(ctx, d.InsertSQL, key, cVal, dVal, createRevision, previousRevision, ttl, value, prevValue)
 }
diff --git a/vendor/github.com/k3s-io/kine/pkg/drivers/generic/tx.go b/vendor/github.com/k3s-io/kine/pkg/drivers/generic/tx.go
new file mode 100644
index 00000000000..166af372a7a
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/pkg/drivers/generic/tx.go
@@ -0,0 +1,109 @@
+package generic
+
+import (
+	"context"
+	"database/sql"
+
+	"github.com/sirupsen/logrus"
+)
+
+type Tx struct {
+	x *sql.Tx
+	d *Generic
+}
+
+func (d *Generic) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
+	logrus.Tracef("TX BEGIN")
+	x, err := d.DB.BeginTx(ctx, opts)
+	if err != nil {
+		return nil, err
+	}
+	return &Tx{
+		x: x,
+		d: d,
+	}, nil
+}
+
+func (t *Tx) Commit() error {
+	logrus.Tracef("TX COMMIT")
+	return t.x.Commit()
+}
+
+func (t *Tx) MustCommit() {
+	if err := t.Commit(); err != nil {
+		logrus.Fatalf("Transaction commit failed: %v", err)
+	}
+}
+
+func (t *Tx) Rollback() error {
+	logrus.Tracef("TX ROLLBACK")
+	return t.x.Rollback()
+}
+
+func (t *Tx) MustRollback() {
+	if err := t.Rollback(); err != nil {
+		if err != sql.ErrTxDone {
+			logrus.Fatalf("Transaction rollback failed: %v", err)
+		}
+	}
+}
+
+func (t *Tx) GetCompactRevision(ctx context.Context) (int64, error) {
+	var id int64
+	row := t.queryRow(ctx, compactRevSQL)
+	err := row.Scan(&id)
+	if err == sql.ErrNoRows {
+		return 0, nil
+	}
+	return id, err
+}
+
+func (t *Tx) SetCompactRevision(ctx context.Context, revision int64) error {
+	logrus.Tracef("TX SETCOMPACTREVISION %v", revision)
+	_, err := t.execute(ctx, t.d.UpdateCompactSQL, revision)
+	return err
+}
+
+func (t *Tx) Compact(ctx context.Context, revision int64) (int64, error) {
+	logrus.Tracef("TX COMPACT %v", revision)
+	res, err := t.execute(ctx, t.d.CompactSQL, revision, revision)
+	if err != nil {
+		return 0, err
+	}
+	return res.RowsAffected()
+}
+
+func (t *Tx) GetRevision(ctx context.Context, revision int64) (*sql.Rows, error) {
+	return t.query(ctx, t.d.GetRevisionSQL, revision)
+}
+
+func (t *Tx) DeleteRevision(ctx context.Context, revision int64) error {
+	logrus.Tracef("TX DELETEREVISION %v", revision)
+	_, err := t.execute(ctx, t.d.DeleteSQL, revision)
+	return err
+}
+
+func (t *Tx) CurrentRevision(ctx context.Context) (int64, error) {
+	var id int64
+	row := t.queryRow(ctx, revSQL)
+	err := row.Scan(&id)
+	if err == sql.ErrNoRows {
+		return 0, nil
+	}
+	return id, err
+}
+
+func (t *Tx) query(ctx context.Context, sql string, args ...interface{}) (*sql.Rows, error) {
+	logrus.Tracef("TX QUERY %v : %s", args, Stripped(sql))
+	return t.x.QueryContext(ctx, sql, args...)
+}
+
+func (t *Tx) queryRow(ctx context.Context, sql string, args ...interface{}) *sql.Row {
+	logrus.Tracef("TX QUERY ROW %v : %s", args, Stripped(sql))
+	return t.x.QueryRowContext(ctx, sql, args...)
+}
+
+func (t *Tx) execute(ctx context.Context, sql string, args ...interface{}) (result sql.Result, err error) {
+	logrus.Tracef("TX EXEC %v : %s", args, Stripped(sql))
+	return t.x.ExecContext(ctx, sql, args...)
+}
diff --git a/vendor/github.com/rancher/kine/pkg/drivers/mysql/mysql.go b/vendor/github.com/k3s-io/kine/pkg/drivers/mysql/mysql.go
similarity index 63%
rename from vendor/github.com/rancher/kine/pkg/drivers/mysql/mysql.go
rename to vendor/github.com/k3s-io/kine/pkg/drivers/mysql/mysql.go
index 0fc456301b6..9a40c33e4ae 100644
--- a/vendor/github.com/rancher/kine/pkg/drivers/mysql/mysql.go
+++ b/vendor/github.com/k3s-io/kine/pkg/drivers/mysql/mysql.go
@@ -6,11 +6,12 @@ import (
 	"database/sql"
 
 	"github.com/go-sql-driver/mysql"
-	"github.com/rancher/kine/pkg/drivers/generic"
-	"github.com/rancher/kine/pkg/logstructured"
-	"github.com/rancher/kine/pkg/logstructured/sqllog"
-	"github.com/rancher/kine/pkg/server"
-	"github.com/rancher/kine/pkg/tls"
+	"github.com/k3s-io/kine/pkg/drivers/generic"
+	"github.com/k3s-io/kine/pkg/logstructured"
+	"github.com/k3s-io/kine/pkg/logstructured/sqllog"
+	"github.com/k3s-io/kine/pkg/server"
+	"github.com/k3s-io/kine/pkg/tls"
+	"github.com/sirupsen/logrus"
 )
 
 const (
@@ -20,27 +21,29 @@ const (
 
 var (
 	schema = []string{
-		`create table if not exists kine
+		`CREATE TABLE IF NOT EXISTS kine
 			(
 				id INTEGER AUTO_INCREMENT,
 				name VARCHAR(630),
 				created INTEGER,
 				deleted INTEGER,
 				create_revision INTEGER,
-				prev_revision INTEGER,
+ 				prev_revision INTEGER,
 				lease INTEGER,
 				value MEDIUMBLOB,
 				old_value MEDIUMBLOB,
 				PRIMARY KEY (id)
 			);`,
+		`CREATE INDEX kine_name_index ON kine (name)`,
+		`CREATE INDEX kine_name_id_index ON kine (name,id)`,
+		`CREATE INDEX kine_id_deleted_index ON kine (id,deleted)`,
+		`CREATE INDEX kine_prev_revision_index ON kine (prev_revision)`,
+		`CREATE UNIQUE INDEX kine_name_prev_revision_uindex ON kine (name, prev_revision)`,
 	}
-	nameIdx     = "create index kine_name_index on kine (name)"
-	nameIDIdx   = "create index kine_name_id_index on kine (name,id)"
-	revisionIdx = "create unique index kine_name_prev_revision_uindex on kine (name, prev_revision)"
-	createDB    = "create database if not exists "
+	createDB = "CREATE DATABASE IF NOT EXISTS "
 )
 
-func New(ctx context.Context, dataSourceName string, tlsInfo tls.Config) (server.Backend, error) {
+func New(ctx context.Context, dataSourceName string, tlsInfo tls.Config, connPoolConfig generic.ConnectionPoolConfig) (server.Backend, error) {
 	tlsConfig, err := tlsInfo.ClientConfig()
 	if err != nil {
 		return nil, err
@@ -59,11 +62,29 @@ func New(ctx context.Context, dataSourceName string, tlsInfo tls.Config) (server
 		return nil, err
 	}
 
-	dialect, err := generic.Open(ctx, "mysql", parsedDSN, "?", false)
+	dialect, err := generic.Open(ctx, "mysql", parsedDSN, connPoolConfig, "?", false)
 	if err != nil {
 		return nil, err
 	}
+
 	dialect.LastInsertID = true
+	dialect.CompactSQL = `
+		DELETE kv FROM kine AS kv
+		INNER JOIN (
+			SELECT kp.prev_revision AS id
+			FROM kine AS kp
+			WHERE
+				kp.name != 'compact_rev_key' AND
+				kp.prev_revision != 0 AND
+				kp.id <= ?
+			UNION
+			SELECT kd.id AS id
+			FROM kine AS kd
+			WHERE
+				kd.deleted != 0 AND
+				kd.id <= ?
+		) AS ks
+		ON kv.id = ks.id`
 	dialect.TranslateErr = func(err error) error {
 		if err, ok := err.(*mysql.MySQLError); ok && err.Number == 1062 {
 			return server.ErrKeyExists
@@ -79,24 +100,19 @@ func New(ctx context.Context, dataSourceName string, tlsInfo tls.Config) (server
 }
 
 func setup(db *sql.DB) error {
+	logrus.Infof("Configuring database table schema and indexes, this may take a moment...")
+
 	for _, stmt := range schema {
+		logrus.Tracef("SETUP EXEC : %v", generic.Stripped(stmt))
 		_, err := db.Exec(stmt)
 		if err != nil {
-			return err
+			if mysqlError, ok := err.(*mysql.MySQLError); !ok || mysqlError.Number != 1061 {
+				return err
+			}
 		}
 	}
-	// check if duplicate indexes
-	indexes := []string{
-		nameIdx,
-		nameIDIdx,
-		revisionIdx}
 
-	for _, idx := range indexes {
-		err := createIndex(db, idx)
-		if err != nil {
-			return err
-		}
-	}
+	logrus.Infof("Database tables and indexes are up to date")
 	return nil
 }
 
@@ -156,13 +172,3 @@ func prepareDSN(dataSourceName string, tlsConfig *cryptotls.Config) (string, err
 
 	return parsedDSN, nil
 }
-
-func createIndex(db *sql.DB, indexStmt string) error {
-	_, err := db.Exec(indexStmt)
-	if err != nil {
-		if mysqlError, ok := err.(*mysql.MySQLError); !ok || mysqlError.Number != 1061 {
-			return err
-		}
-	}
-	return nil
-}
diff --git a/vendor/github.com/rancher/kine/pkg/drivers/pgsql/pgsql.go b/vendor/github.com/k3s-io/kine/pkg/drivers/pgsql/pgsql.go
similarity index 69%
rename from vendor/github.com/rancher/kine/pkg/drivers/pgsql/pgsql.go
rename to vendor/github.com/k3s-io/kine/pkg/drivers/pgsql/pgsql.go
index 7dd7a2a401d..8d2669f0dd6 100644
--- a/vendor/github.com/rancher/kine/pkg/drivers/pgsql/pgsql.go
+++ b/vendor/github.com/k3s-io/kine/pkg/drivers/pgsql/pgsql.go
@@ -8,12 +8,13 @@ import (
 	"strconv"
 	"strings"
 
+	"github.com/k3s-io/kine/pkg/drivers/generic"
+	"github.com/k3s-io/kine/pkg/logstructured"
+	"github.com/k3s-io/kine/pkg/logstructured/sqllog"
+	"github.com/k3s-io/kine/pkg/server"
+	"github.com/k3s-io/kine/pkg/tls"
 	"github.com/lib/pq"
-	"github.com/rancher/kine/pkg/drivers/generic"
-	"github.com/rancher/kine/pkg/logstructured"
-	"github.com/rancher/kine/pkg/logstructured/sqllog"
-	"github.com/rancher/kine/pkg/server"
-	"github.com/rancher/kine/pkg/tls"
+	"github.com/sirupsen/logrus"
 )
 
 const (
@@ -22,26 +23,28 @@ const (
 
 var (
 	schema = []string{
-		`create table if not exists kine
-			(
-				id SERIAL PRIMARY KEY,
+		`CREATE TABLE IF NOT EXISTS kine
+ 			(
+ 				id SERIAL PRIMARY KEY,
 				name VARCHAR(630),
 				created INTEGER,
 				deleted INTEGER,
-				create_revision INTEGER,
-				prev_revision INTEGER,
-				lease INTEGER,
-				value bytea,
-				old_value bytea
-			);`,
+ 				create_revision INTEGER,
+ 				prev_revision INTEGER,
+ 				lease INTEGER,
+ 				value bytea,
+ 				old_value bytea
+ 			);`,
 		`CREATE INDEX IF NOT EXISTS kine_name_index ON kine (name)`,
 		`CREATE INDEX IF NOT EXISTS kine_name_id_index ON kine (name,id)`,
+		`CREATE INDEX IF NOT EXISTS kine_id_deleted_index ON kine (id,deleted)`,
+		`CREATE INDEX IF NOT EXISTS kine_prev_revision_index ON kine (prev_revision)`,
 		`CREATE UNIQUE INDEX IF NOT EXISTS kine_name_prev_revision_uindex ON kine (name, prev_revision)`,
 	}
-	createDB = "create database "
+	createDB = "CREATE DATABASE "
 )
 
-func New(ctx context.Context, dataSourceName string, tlsInfo tls.Config) (server.Backend, error) {
+func New(ctx context.Context, dataSourceName string, tlsInfo tls.Config, connPoolConfig generic.ConnectionPoolConfig) (server.Backend, error) {
 	parsedDSN, err := prepareDSN(dataSourceName, tlsInfo)
 	if err != nil {
 		return nil, err
@@ -51,10 +54,27 @@ func New(ctx context.Context, dataSourceName string, tlsInfo tls.Config) (server
 		return nil, err
 	}
 
-	dialect, err := generic.Open(ctx, "postgres", parsedDSN, "$", true)
+	dialect, err := generic.Open(ctx, "postgres", parsedDSN, connPoolConfig, "$", true)
 	if err != nil {
 		return nil, err
 	}
+	dialect.CompactSQL = `
+		DELETE FROM kine AS kv
+		USING	(
+			SELECT kp.prev_revision AS id
+			FROM kine AS kp
+			WHERE
+				kp.name != 'compact_rev_key' AND
+				kp.prev_revision != 0 AND
+				kp.id <= $1
+			UNION
+			SELECT kd.id AS id
+			FROM kine AS kd
+			WHERE
+				kd.deleted != 0 AND
+				kd.id <= $2
+		) AS ks
+		WHERE kv.id = ks.id`
 	dialect.TranslateErr = func(err error) error {
 		if err, ok := err.(*pq.Error); ok && err.Code == "23505" {
 			return server.ErrKeyExists
@@ -71,13 +91,17 @@ func New(ctx context.Context, dataSourceName string, tlsInfo tls.Config) (server
 }
 
 func setup(db *sql.DB) error {
+	logrus.Infof("Configuring database table schema and indexes, this may take a moment...")
+
 	for _, stmt := range schema {
+		logrus.Tracef("SETUP EXEC : %v", generic.Stripped(stmt))
 		_, err := db.Exec(stmt)
 		if err != nil {
 			return err
 		}
 	}
 
+	logrus.Infof("Database tables and indexes are up to date")
 	return nil
 }
 
@@ -110,7 +134,9 @@ func createDBIfNotExist(dataSourceName string) error {
 			return err
 		}
 		defer db.Close()
-		_, err = db.Exec(createDB + dbName + ";")
+		stmt := createDB + dbName + ";"
+		logrus.Tracef("SETUP EXEC : %v", generic.Stripped(stmt))
+		_, err = db.Exec(stmt)
 		if err != nil {
 			return err
 		}
diff --git a/vendor/github.com/rancher/kine/pkg/drivers/sqlite/sqlite.go b/vendor/github.com/k3s-io/kine/pkg/drivers/sqlite/sqlite.go
similarity index 57%
rename from vendor/github.com/rancher/kine/pkg/drivers/sqlite/sqlite.go
rename to vendor/github.com/k3s-io/kine/pkg/drivers/sqlite/sqlite.go
index f4d1127d5a0..86d10861675 100644
--- a/vendor/github.com/rancher/kine/pkg/drivers/sqlite/sqlite.go
+++ b/vendor/github.com/k3s-io/kine/pkg/drivers/sqlite/sqlite.go
@@ -8,12 +8,12 @@ import (
 	"os"
 	"time"
 
+	"github.com/k3s-io/kine/pkg/drivers/generic"
+	"github.com/k3s-io/kine/pkg/logstructured"
+	"github.com/k3s-io/kine/pkg/logstructured/sqllog"
+	"github.com/k3s-io/kine/pkg/server"
 	"github.com/mattn/go-sqlite3"
 	"github.com/pkg/errors"
-	"github.com/rancher/kine/pkg/drivers/generic"
-	"github.com/rancher/kine/pkg/logstructured"
-	"github.com/rancher/kine/pkg/logstructured/sqllog"
-	"github.com/rancher/kine/pkg/server"
 	"github.com/sirupsen/logrus"
 
 	// sqlite db driver
@@ -24,7 +24,7 @@ var (
 	schema = []string{
 		`CREATE TABLE IF NOT EXISTS kine
 			(
-				id INTEGER primary key autoincrement,
+				id INTEGER PRIMARY KEY AUTOINCREMENT,
 				name INTEGER,
 				created INTEGER,
 				deleted INTEGER,
@@ -35,16 +35,19 @@ var (
 				old_value BLOB
 			)`,
 		`CREATE INDEX IF NOT EXISTS kine_name_index ON kine (name)`,
+		`CREATE INDEX IF NOT EXISTS kine_name_id_index ON kine (name,id)`,
+		`CREATE INDEX IF NOT EXISTS kine_id_deleted_index ON kine (id,deleted)`,
+		`CREATE INDEX IF NOT EXISTS kine_prev_revision_index ON kine (prev_revision)`,
 		`CREATE UNIQUE INDEX IF NOT EXISTS kine_name_prev_revision_uindex ON kine (name, prev_revision)`,
 	}
 )
 
-func New(ctx context.Context, dataSourceName string) (server.Backend, error) {
-	backend, _, err := NewVariant(ctx, "sqlite3", dataSourceName)
+func New(ctx context.Context, dataSourceName string, connPoolConfig generic.ConnectionPoolConfig) (server.Backend, error) {
+	backend, _, err := NewVariant(ctx, "sqlite3", dataSourceName, connPoolConfig)
 	return backend, err
 }
 
-func NewVariant(ctx context.Context, driverName, dataSourceName string) (server.Backend, *generic.Generic, error) {
+func NewVariant(ctx context.Context, driverName, dataSourceName string, connPoolConfig generic.ConnectionPoolConfig) (server.Backend, *generic.Generic, error) {
 	if dataSourceName == "" {
 		if err := os.MkdirAll("./db", 0700); err != nil {
 			return nil, nil, err
@@ -52,11 +55,29 @@ func NewVariant(ctx context.Context, driverName, dataSourceName string) (server.
 		dataSourceName = "./db/state.db?_journal=WAL&cache=shared"
 	}
 
-	dialect, err := generic.Open(ctx, driverName, dataSourceName, "?", false)
+	dialect, err := generic.Open(ctx, driverName, dataSourceName, connPoolConfig, "?", false)
 	if err != nil {
 		return nil, nil, err
 	}
+
 	dialect.LastInsertID = true
+	dialect.CompactSQL = `
+		DELETE FROM kine AS kv
+		WHERE
+			kv.id IN (
+				SELECT kp.prev_revision AS id
+				FROM kine AS kp
+				WHERE
+					kp.name != 'compact_rev_key' AND
+					kp.prev_revision != 0 AND
+					kp.id <= ?
+				UNION
+				SELECT kd.id AS id
+				FROM kine AS kd
+				WHERE
+					kd.deleted != 0 AND
+					kd.id <= ?
+			)`
 	dialect.TranslateErr = func(err error) error {
 		if err, ok := err.(sqlite3.Error); ok && err.ExtendedCode == sqlite3.ErrConstraintUnique {
 			return server.ErrKeyExists
@@ -82,21 +103,22 @@ func NewVariant(ctx context.Context, driverName, dataSourceName string) (server.
 	if err != nil {
 		return nil, nil, errors.Wrap(err, "setup db")
 	}
-	//if err := setup(dialect.DB); err != nil {
-	//	return nil, nil, errors.Wrap(err, "setup db")
-	//}
 
 	dialect.Migrate(context.Background())
 	return logstructured.New(sqllog.New(dialect)), dialect, nil
 }
 
 func setup(db *sql.DB) error {
+	logrus.Infof("Configuring database table schema and indexes, this may take a moment...")
+
 	for _, stmt := range schema {
+		logrus.Tracef("SETUP EXEC : %v", generic.Stripped(stmt))
 		_, err := db.Exec(stmt)
 		if err != nil {
 			return err
 		}
 	}
 
+	logrus.Infof("Database tables and indexes are up to date")
 	return nil
 }
diff --git a/vendor/github.com/k3s-io/kine/pkg/drivers/sqlite/sqlite_nocgo.go b/vendor/github.com/k3s-io/kine/pkg/drivers/sqlite/sqlite_nocgo.go
new file mode 100644
index 00000000000..951319fad8e
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/pkg/drivers/sqlite/sqlite_nocgo.go
@@ -0,0 +1,26 @@
+// +build !cgo
+
+package sqlite
+
+import (
+	"context"
+	"database/sql"
+	"errors"
+
+	"github.com/k3s-io/kine/pkg/drivers/generic"
+	"github.com/k3s-io/kine/pkg/server"
+)
+
+var errNoCgo = errors.New("this binary is built without CGO, sqlite is disabled")
+
+func New(ctx context.Context, dataSourceName string, connPoolConfig generic.ConnectionPoolConfig) (server.Backend, error) {
+	return nil, errNoCgo
+}
+
+func NewVariant(driverName, dataSourceName string, connPoolConfig generic.ConnectionPoolConfig) (server.Backend, *generic.Generic, error) {
+	return nil, nil, errNoCgo
+}
+
+func setup(db *sql.DB) error {
+	return errNoCgo
+}
diff --git a/vendor/github.com/rancher/kine/pkg/endpoint/endpoint.go b/vendor/github.com/k3s-io/kine/pkg/endpoint/endpoint.go
similarity index 80%
rename from vendor/github.com/rancher/kine/pkg/endpoint/endpoint.go
rename to vendor/github.com/k3s-io/kine/pkg/endpoint/endpoint.go
index e8fc74f7651..c9a7090e674 100644
--- a/vendor/github.com/rancher/kine/pkg/endpoint/endpoint.go
+++ b/vendor/github.com/k3s-io/kine/pkg/endpoint/endpoint.go
@@ -7,13 +7,14 @@ import (
 	"os"
 	"strings"
 
+	"github.com/k3s-io/kine/pkg/drivers/dqlite"
+	"github.com/k3s-io/kine/pkg/drivers/generic"
+	"github.com/k3s-io/kine/pkg/drivers/mysql"
+	"github.com/k3s-io/kine/pkg/drivers/pgsql"
+	"github.com/k3s-io/kine/pkg/drivers/sqlite"
+	"github.com/k3s-io/kine/pkg/server"
+	"github.com/k3s-io/kine/pkg/tls"
 	"github.com/pkg/errors"
-	"github.com/rancher/kine/pkg/drivers/dqlite"
-	"github.com/rancher/kine/pkg/drivers/mysql"
-	"github.com/rancher/kine/pkg/drivers/pgsql"
-	"github.com/rancher/kine/pkg/drivers/sqlite"
-	"github.com/rancher/kine/pkg/server"
-	"github.com/rancher/kine/pkg/tls"
 	"github.com/sirupsen/logrus"
 	"google.golang.org/grpc"
 )
@@ -28,9 +29,10 @@ const (
 )
 
 type Config struct {
-	GRPCServer *grpc.Server
-	Listener   string
-	Endpoint   string
+	GRPCServer           *grpc.Server
+	Listener             string
+	Endpoint             string
+	ConnectionPoolConfig generic.ConnectionPoolConfig
 
 	tls.Config
 }
@@ -124,13 +126,13 @@ func getKineStorageBackend(ctx context.Context, driver, dsn string, cfg Config)
 	switch driver {
 	case SQLiteBackend:
 		leaderElect = false
-		backend, err = sqlite.New(ctx, dsn)
+		backend, err = sqlite.New(ctx, dsn, cfg.ConnectionPoolConfig)
 	case DQLiteBackend:
-		backend, err = dqlite.New(ctx, dsn)
+		backend, err = dqlite.New(ctx, dsn, cfg.Config, cfg.ConnectionPoolConfig)
 	case PostgresBackend:
-		backend, err = pgsql.New(ctx, dsn, cfg.Config)
+		backend, err = pgsql.New(ctx, dsn, cfg.Config, cfg.ConnectionPoolConfig)
 	case MySQLBackend:
-		backend, err = mysql.New(ctx, dsn, cfg.Config)
+		backend, err = mysql.New(ctx, dsn, cfg.Config, cfg.ConnectionPoolConfig)
 	default:
 		return false, nil, fmt.Errorf("storage backend is not defined")
 	}
diff --git a/vendor/github.com/rancher/kine/pkg/logstructured/logstructured.go b/vendor/github.com/k3s-io/kine/pkg/logstructured/logstructured.go
similarity index 88%
rename from vendor/github.com/rancher/kine/pkg/logstructured/logstructured.go
rename to vendor/github.com/k3s-io/kine/pkg/logstructured/logstructured.go
index 9fa4db3783b..3db92c125c2 100644
--- a/vendor/github.com/rancher/kine/pkg/logstructured/logstructured.go
+++ b/vendor/github.com/k3s-io/kine/pkg/logstructured/logstructured.go
@@ -5,7 +5,7 @@ import (
 	"sync"
 	"time"
 
-	"github.com/rancher/kine/pkg/server"
+	"github.com/k3s-io/kine/pkg/server"
 	"github.com/sirupsen/logrus"
 )
 
@@ -33,7 +33,12 @@ func (l *LogStructured) Start(ctx context.Context) error {
 	if err := l.log.Start(ctx); err != nil {
 		return err
 	}
-	l.Create(ctx, "/registry/health", []byte(`{"health":"true"}`), 0)
+	// See https://github.com/kubernetes/kubernetes/blob/442a69c3bdf6fe8e525b05887e57d89db1e2f3a5/staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/etcd3.go#L97
+	if _, err := l.Create(ctx, "/registry/health", []byte(`{"health":"true"}`), 0); err != nil {
+		if err != server.ErrKeyExists {
+			logrus.Errorf("Failed to create health check key: %v", err)
+		}
+	}
 	go l.ttl(ctx)
 	return nil
 }
@@ -41,7 +46,7 @@ func (l *LogStructured) Start(ctx context.Context) error {
 func (l *LogStructured) Get(ctx context.Context, key string, revision int64) (revRet int64, kvRet *server.KeyValue, errRet error) {
 	defer func() {
 		l.adjustRevision(ctx, &revRet)
-		logrus.Debugf("GET %s, rev=%d => rev=%d, kv=%v, err=%v", key, revision, revRet, kvRet != nil, errRet)
+		logrus.Tracef("GET %s, rev=%d => rev=%d, kv=%v, err=%v", key, revision, revRet, kvRet != nil, errRet)
 	}()
 
 	rev, event, err := l.get(ctx, key, revision, false)
@@ -82,7 +87,7 @@ func (l *LogStructured) adjustRevision(ctx context.Context, rev *int64) {
 func (l *LogStructured) Create(ctx context.Context, key string, value []byte, lease int64) (revRet int64, errRet error) {
 	defer func() {
 		l.adjustRevision(ctx, &revRet)
-		logrus.Debugf("CREATE %s, size=%d, lease=%d => rev=%d, err=%v", key, len(value), lease, revRet, errRet)
+		logrus.Tracef("CREATE %s, size=%d, lease=%d => rev=%d, err=%v", key, len(value), lease, revRet, errRet)
 	}()
 
 	rev, prevEvent, err := l.get(ctx, key, 0, true)
@@ -114,7 +119,7 @@ func (l *LogStructured) Create(ctx context.Context, key string, value []byte, le
 func (l *LogStructured) Delete(ctx context.Context, key string, revision int64) (revRet int64, kvRet *server.KeyValue, deletedRet bool, errRet error) {
 	defer func() {
 		l.adjustRevision(ctx, &revRet)
-		logrus.Debugf("DELETE %s, rev=%d => rev=%d, kv=%v, deleted=%v, err=%v", key, revision, revRet, kvRet != nil, deletedRet, errRet)
+		logrus.Tracef("DELETE %s, rev=%d => rev=%d, kv=%v, deleted=%v, err=%v", key, revision, revRet, kvRet != nil, deletedRet, errRet)
 	}()
 
 	rev, event, err := l.get(ctx, key, 0, true)
@@ -155,7 +160,7 @@ func (l *LogStructured) Delete(ctx context.Context, key string, revision int64)
 
 func (l *LogStructured) List(ctx context.Context, prefix, startKey string, limit, revision int64) (revRet int64, kvRet []*server.KeyValue, errRet error) {
 	defer func() {
-		logrus.Debugf("LIST %s, start=%s, limit=%d, rev=%d => rev=%d, kvs=%d, err=%v", prefix, startKey, limit, revision, revRet, len(kvRet), errRet)
+		logrus.Tracef("LIST %s, start=%s, limit=%d, rev=%d => rev=%d, kvs=%d, err=%v", prefix, startKey, limit, revision, revRet, len(kvRet), errRet)
 	}()
 
 	rev, events, err := l.log.List(ctx, prefix, startKey, limit, revision, false)
@@ -185,7 +190,7 @@ func (l *LogStructured) List(ctx context.Context, prefix, startKey string, limit
 
 func (l *LogStructured) Count(ctx context.Context, prefix string) (revRet int64, count int64, err error) {
 	defer func() {
-		logrus.Debugf("COUNT %s => rev=%d, count=%d, err=%v", prefix, revRet, count, err)
+		logrus.Tracef("COUNT %s => rev=%d, count=%d, err=%v", prefix, revRet, count, err)
 	}()
 	rev, count, err := l.log.Count(ctx, prefix)
 	if err != nil {
@@ -211,7 +216,7 @@ func (l *LogStructured) Update(ctx context.Context, key string, value []byte, re
 		if kvRet != nil {
 			kvRev = kvRet.ModRevision
 		}
-		logrus.Debugf("UPDATE %s, value=%d, rev=%d, lease=%v => rev=%d, kvrev=%d, updated=%v, err=%v", key, len(value), revision, lease, revRet, kvRev, updateRet, errRet)
+		logrus.Tracef("UPDATE %s, value=%d, rev=%d, lease=%v => rev=%d, kvrev=%d, updated=%v, err=%v", key, len(value), revision, lease, revRet, kvRev, updateRet, errRet)
 	}()
 
 	rev, event, err := l.get(ctx, key, 0, false)
@@ -304,14 +309,16 @@ func (l *LogStructured) ttl(ctx context.Context) {
 			case <-time.After(time.Duration(event.KV.Lease) * time.Second):
 			}
 			mutex.Lock()
-			l.Delete(ctx, event.KV.Key, event.KV.ModRevision)
+			if _, _, _, err := l.Delete(ctx, event.KV.Key, event.KV.ModRevision); err != nil {
+				logrus.Errorf("failed to delete expired key: %v", err)
+			}
 			mutex.Unlock()
 		}(event)
 	}
 }
 
 func (l *LogStructured) Watch(ctx context.Context, prefix string, revision int64) <-chan []*server.Event {
-	logrus.Debugf("WATCH %s, revision=%d", prefix, revision)
+	logrus.Tracef("WATCH %s, revision=%d", prefix, revision)
 
 	// starting watching right away so we don't miss anything
 	ctx, cancel := context.WithCancel(ctx)
@@ -319,7 +326,7 @@ func (l *LogStructured) Watch(ctx context.Context, prefix string, revision int64
 
 	// include the current revision in list
 	if revision > 0 {
-		revision -= 1
+		revision--
 	}
 
 	result := make(chan []*server.Event, 100)
@@ -330,7 +337,7 @@ func (l *LogStructured) Watch(ctx context.Context, prefix string, revision int64
 		cancel()
 	}
 
-	logrus.Debugf("WATCH LIST key=%s rev=%d => rev=%d kvs=%d", prefix, revision, rev, len(kvs))
+	logrus.Tracef("WATCH LIST key=%s rev=%d => rev=%d kvs=%d", prefix, revision, rev, len(kvs))
 
 	go func() {
 		lastRevision := revision
diff --git a/vendor/github.com/rancher/kine/pkg/logstructured/sqllog/sql.go b/vendor/github.com/k3s-io/kine/pkg/logstructured/sqllog/sql.go
similarity index 60%
rename from vendor/github.com/rancher/kine/pkg/logstructured/sqllog/sql.go
rename to vendor/github.com/k3s-io/kine/pkg/logstructured/sqllog/sql.go
index 18235a75edb..b7aec6d8fa3 100644
--- a/vendor/github.com/rancher/kine/pkg/logstructured/sqllog/sql.go
+++ b/vendor/github.com/k3s-io/kine/pkg/logstructured/sqllog/sql.go
@@ -6,11 +6,21 @@ import (
 	"strings"
 	"time"
 
-	"github.com/rancher/kine/pkg/broadcaster"
-	"github.com/rancher/kine/pkg/server"
+	"github.com/k3s-io/kine/pkg/broadcaster"
+	"github.com/k3s-io/kine/pkg/drivers/generic"
+	"github.com/k3s-io/kine/pkg/server"
+	"github.com/pkg/errors"
 	"github.com/sirupsen/logrus"
 )
 
+const (
+	compactInterval  = 5 * time.Minute
+	compactTimeout   = 5 * time.Second
+	compactMinRetain = 1000
+	compactBatchSize = 1000
+	pollBatchSize    = 500
+)
+
 type SQLLog struct {
 	d           Dialect
 	broadcaster broadcaster.Broadcaster
@@ -37,8 +47,10 @@ type Dialect interface {
 	DeleteRevision(ctx context.Context, revision int64) error
 	GetCompactRevision(ctx context.Context) (int64, error)
 	SetCompactRevision(ctx context.Context, revision int64) error
+	Compact(ctx context.Context, revision int64) (int64, error)
 	Fill(ctx context.Context, revision int64) error
 	IsFill(key string) bool
+	BeginTx(ctx context.Context, opts *sql.TxOptions) (*generic.Tx, error)
 }
 
 func (s *SQLLog) Start(ctx context.Context) (err error) {
@@ -47,6 +59,8 @@ func (s *SQLLog) Start(ctx context.Context) (err error) {
 }
 
 func (s *SQLLog) compactStart(ctx context.Context) error {
+	logrus.Tracef("COMPACTSTART")
+
 	rows, err := s.d.After(ctx, "compact_rev_key", 0, 0)
 	if err != nil {
 		return err
@@ -57,6 +71,8 @@ func (s *SQLLog) compactStart(ctx context.Context) error {
 		return err
 	}
 
+	logrus.Tracef("COMPACTSTART len(events)=%v", len(events))
+
 	if len(events) == 0 {
 		_, err := s.Append(ctx, &server.Event{
 			Create: true,
@@ -70,6 +86,12 @@ func (s *SQLLog) compactStart(ctx context.Context) error {
 		return nil
 	}
 
+	t, err := s.d.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
+	if err != nil {
+		return err
+	}
+	defer t.MustRollback()
+
 	// this is to work around a bug in which we ended up with two compact_rev_key rows
 	maxRev := int64(0)
 	maxID := int64(0)
@@ -78,26 +100,33 @@ func (s *SQLLog) compactStart(ctx context.Context) error {
 			maxRev = event.PrevKV.ModRevision
 			maxID = event.KV.ModRevision
 		}
+		logrus.Tracef("COMPACTSTART maxRev=%v maxID=%v", maxRev, maxID)
 	}
 
 	for _, event := range events {
+		logrus.Tracef("COMPACTSTART event.KV.ModRevision=%v maxID=%v", event.KV.ModRevision, maxID)
 		if event.KV.ModRevision == maxID {
 			continue
 		}
-		if err := s.d.DeleteRevision(ctx, event.KV.ModRevision); err != nil {
+		if err := t.DeleteRevision(ctx, event.KV.ModRevision); err != nil {
 			return err
 		}
 	}
 
-	return nil
+	return t.Commit()
 }
 
-func (s *SQLLog) compact() {
-	var (
-		nextEnd int64
-	)
-	t := time.NewTicker(5 * time.Minute)
-	nextEnd, _ = s.d.CurrentRevision(s.ctx)
+// compactor periodically compacts historical versions of keys.
+// It will compact keys with versions older than given interval, but never within the last 1000 revisions.
+// In other words, after compaction, it will only contain key revisions set during last interval.
+// Any API call for the older versions of keys will return error.
+// Interval is the time interval between each compaction. The first compaction happens after "interval".
+// This logic is directly cribbed from k8s.io/apiserver/pkg/storage/etcd3/compact.go
+func (s *SQLLog) compactor(interval time.Duration) {
+	t := time.NewTicker(interval)
+	compactRev, _ := s.d.GetCompactRevision(s.ctx)
+	targetCompactRev, _ := s.d.CurrentRevision(s.ctx)
+	logrus.Tracef("COMPACT starting compactRev=%d targetCompactRev=%d", compactRev, targetCompactRev)
 
 outer:
 	for {
@@ -107,91 +136,104 @@ outer:
 		case <-t.C:
 		}
 
-		currentRev, err := s.d.CurrentRevision(s.ctx)
-		if err != nil {
-			logrus.Errorf("failed to get current revision: %v", err)
-			continue
-		}
-
-		end := nextEnd
-		nextEnd = currentRev
+		// Break up the compaction into smaller batches to avoid locking the database with excessively
+		// long transactions. When things are working normally deletes should proceed quite quickly, but if
+		// run against a database where compaction has stalled (see rancher/k3s#1311) it may take a long time
+		// (several hundred ms) just for the database to execute the subquery to select the revisions to delete.
 
-		cursor, err := s.d.GetCompactRevision(s.ctx)
-		if err != nil {
-			logrus.Errorf("failed to get compact revision: %v", err)
-			continue
-		}
+		var (
+			iterCompactRev int64
+			compactedRev   int64
+			currentRev     int64
+			err            error
+		)
 
-		// leave the last 1000
-		end = end - 1000
+		iterCompactRev = compactRev
+		compactedRev = compactRev
 
-		savedCursor := cursor
-		// Purposefully start at the current and redo the current as
-		// it could have failed before actually compacting
-		for ; cursor <= end; cursor++ {
-			rows, err := s.d.GetRevision(s.ctx, cursor)
-			if err != nil {
-				logrus.Errorf("failed to get revision %d: %v", cursor, err)
-				continue outer
+		for iterCompactRev < targetCompactRev {
+			// Set move iteration target compactBatchSize revisions forward, or
+			// just as far as we need to hit the compaction target if that would
+			// overshoot it.
+			iterCompactRev += compactBatchSize
+			if iterCompactRev > targetCompactRev {
+				iterCompactRev = targetCompactRev
 			}
 
-			_, _, events, err := RowsToEvents(rows)
+			compactedRev, currentRev, err = s.compact(compactedRev, iterCompactRev)
 			if err != nil {
-				logrus.Errorf("failed to convert to events: %v", err)
-				continue outer
+				// ErrCompacted indicates that no further work is necessary - either compactRev changed since the
+				// last iteration because another client has compacted, or the requested revision has already been compacted.
+				if err == server.ErrCompacted {
+					break
+				} else {
+					logrus.Errorf("Compact failed: %v", err)
+					continue outer
+				}
 			}
+		}
 
-			if len(events) == 0 {
-				continue
-			}
+		// Record the final results for the outer loop
+		compactRev = compactedRev
+		targetCompactRev = currentRev
+	}
+}
 
-			event := events[0]
+// compact removes deleted or replaced rows from the database. compactRev is the revision that was last compacted to.
+// If this changes between compactions, we know that someone else has compacted and we don't need to do it.
+// targetCompactRev is the revision that we should try to compact to. Upon success, the function returns the revision
+// compacted to, and the revision that we should try to compact to next time (the current revision).
+// This logic is directly cribbed from k8s.io/apiserver/pkg/storage/etcd3/compact.go
+func (s *SQLLog) compact(compactRev int64, targetCompactRev int64) (int64, int64, error) {
+	ctx, cancel := context.WithTimeout(s.ctx, compactTimeout)
+	defer cancel()
 
-			if event.KV.Key == "compact_rev_key" {
-				// don't compact the compact key
-				continue
-			}
+	t, err := s.d.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
+	if err != nil {
+		return compactRev, targetCompactRev, errors.Wrap(err, "failed to begin transaction")
+	}
+	defer t.MustRollback()
 
-			setRev := false
-			if event.PrevKV != nil && event.PrevKV.ModRevision != 0 {
-				if savedCursor != cursor {
-					if err := s.d.SetCompactRevision(s.ctx, cursor); err != nil {
-						logrus.Errorf("failed to record compact revision: %v", err)
-						continue outer
-					}
-					savedCursor = cursor
-					setRev = true
-				}
+	currentRev, err := t.CurrentRevision(s.ctx)
+	if err != nil {
+		return compactRev, targetCompactRev, errors.Wrap(err, "failed to get current revision")
+	}
 
-				if err := s.d.DeleteRevision(s.ctx, event.PrevKV.ModRevision); err != nil {
-					logrus.Errorf("failed to delete revision %d: %v", event.PrevKV.ModRevision, err)
-					continue outer
-				}
-			}
+	dbCompactRev, err := t.GetCompactRevision(s.ctx)
+	if err != nil {
+		return compactRev, targetCompactRev, errors.Wrap(err, "failed to get compact revision")
+	}
 
-			if event.Delete {
-				if !setRev && savedCursor != cursor {
-					if err := s.d.SetCompactRevision(s.ctx, cursor); err != nil {
-						logrus.Errorf("failed to record compact revision: %v", err)
-						continue outer
-					}
-					savedCursor = cursor
-				}
+	if compactRev != dbCompactRev {
+		logrus.Tracef("COMPACT compact revision changed since last iteration: %d => %d", compactRev, dbCompactRev)
+		return dbCompactRev, currentRev, server.ErrCompacted
+	}
 
-				if err := s.d.DeleteRevision(s.ctx, cursor); err != nil {
-					logrus.Errorf("failed to delete current revision %d: %v", cursor, err)
-					continue outer
-				}
-			}
-		}
+	// Ensure that we never compact the most recent 1000 revisions
+	targetCompactRev = safeCompactRev(targetCompactRev, currentRev)
 
-		if savedCursor != cursor {
-			if err := s.d.SetCompactRevision(s.ctx, cursor); err != nil {
-				logrus.Errorf("failed to record compact revision: %v", err)
-				continue outer
-			}
-		}
+	// Don't bother compacting to a revision that has already been compacted
+	if targetCompactRev <= compactRev {
+		logrus.Tracef("COMPACT revision %d has already been compacted", targetCompactRev)
+		return dbCompactRev, currentRev, server.ErrCompacted
+	}
+
+	logrus.Tracef("COMPACT compactRev=%d targetCompactRev=%d currentRev=%d", compactRev, targetCompactRev, currentRev)
+
+	start := time.Now()
+	deletedRows, err := t.Compact(s.ctx, targetCompactRev)
+	if err != nil {
+		return compactRev, targetCompactRev, errors.Wrapf(err, "failed to compact to revision %d", targetCompactRev)
 	}
+
+	if err := t.SetCompactRevision(s.ctx, targetCompactRev); err != nil {
+		return compactRev, targetCompactRev, errors.Wrap(err, "failed to record compact revision")
+	}
+
+	t.MustCommit()
+	logrus.Debugf("COMPACT deleted %d rows from %d revisions in %s - compacted to %d/%d", deletedRows, (targetCompactRev - compactRev), time.Since(start), targetCompactRev, currentRev)
+
+	return targetCompactRev, currentRev, nil
 }
 
 func (s *SQLLog) CurrentRevision(ctx context.Context) (int64, error) {
@@ -335,7 +377,7 @@ func (s *SQLLog) startWatch() (chan interface{}, error) {
 	c := make(chan interface{})
 	// start compaction and polling at the same time to watch starts
 	// at the oldest revision, but compaction doesn't create gaps
-	go s.compact()
+	go s.compactor(compactInterval)
 	go s.poll(c, pollStart)
 	return c, nil
 }
@@ -366,7 +408,7 @@ func (s *SQLLog) poll(result chan interface{}, pollStart int64) {
 		}
 		waitForMore = true
 
-		rows, err := s.d.After(s.ctx, "%", last, 500)
+		rows, err := s.d.After(s.ctx, "%", last, pollBatchSize)
 		if err != nil {
 			logrus.Errorf("fail to list latest changes: %v", err)
 			continue
@@ -395,6 +437,7 @@ func (s *SQLLog) poll(result chan interface{}, pollStart int64) {
 			// Ensure that we are notifying events in a sequential fashion. For example if we find row 4 before 3
 			// we don't want to notify row 4 because 3 is essentially dropped forever.
 			if event.KV.ModRevision != next {
+				logrus.Tracef("MODREVISION GAP: expected %v, got %v", next, event.KV.ModRevision)
 				if canSkipRevision(next, skip, skipTime) {
 					// This situation should never happen, but we have it here as a fallback just for unknown reasons
 					// we don't want to pause all watches forever
@@ -411,13 +454,13 @@ func (s *SQLLog) poll(result chan interface{}, pollStart int64) {
 					break
 				} else {
 					if err := s.d.Fill(s.ctx, next); err == nil {
-						logrus.Debugf("FILL, revision=%d, err=%v", next, err)
+						logrus.Tracef("FILL, revision=%d, err=%v", next, err)
 						select {
 						case s.notify <- next:
 						default:
 						}
 					} else {
-						logrus.Debugf("FILL FAILED, revision=%d, err=%v", next, err)
+						logrus.Tracef("FILL FAILED, revision=%d, err=%v", next, err)
 					}
 					break
 				}
@@ -431,10 +474,10 @@ func (s *SQLLog) poll(result chan interface{}, pollStart int64) {
 			saveLast = true
 			rev = event.KV.ModRevision
 			if s.d.IsFill(event.KV.Key) {
-				logrus.Debugf("NOT TRIGGER FILL %s, revision=%d, delete=%v", event.KV.Key, event.KV.ModRevision, event.Delete)
+				logrus.Tracef("NOT TRIGGER FILL %s, revision=%d, delete=%v", event.KV.Key, event.KV.ModRevision, event.Delete)
 			} else {
 				sequential = append(sequential, event)
-				logrus.Debugf("TRIGGERED %s, revision=%d, delete=%v", event.KV.Key, event.KV.ModRevision, event.Delete)
+				logrus.Tracef("TRIGGERED %s, revision=%d, delete=%v", event.KV.Key, event.KV.ModRevision, event.Delete)
 			}
 		}
 
@@ -448,7 +491,7 @@ func (s *SQLLog) poll(result chan interface{}, pollStart int64) {
 }
 
 func canSkipRevision(rev, skip int64, skipTime time.Time) bool {
-	return rev == skip && time.Now().Sub(skipTime) > time.Second
+	return rev == skip && time.Since(skipTime) > time.Second
 }
 
 func (s *SQLLog) Count(ctx context.Context, prefix string) (int64, int64, error) {
@@ -517,3 +560,15 @@ func scan(rows *sql.Rows, rev *int64, compact *int64, event *server.Event) error
 	*compact = c.Int64
 	return nil
 }
+
+// safeCompactRev ensures that we never compact the most recent 1000 revisions.
+func safeCompactRev(targetCompactRev int64, currentRev int64) int64 {
+	safeRev := currentRev - compactMinRetain
+	if targetCompactRev < safeRev {
+		safeRev = targetCompactRev
+	}
+	if safeRev < 0 {
+		safeRev = 0
+	}
+	return safeRev
+}
diff --git a/vendor/github.com/rancher/kine/pkg/server/compact.go b/vendor/github.com/k3s-io/kine/pkg/server/compact.go
similarity index 62%
rename from vendor/github.com/rancher/kine/pkg/server/compact.go
rename to vendor/github.com/k3s-io/kine/pkg/server/compact.go
index ba7f63d400c..e6edc390dd5 100644
--- a/vendor/github.com/rancher/kine/pkg/server/compact.go
+++ b/vendor/github.com/k3s-io/kine/pkg/server/compact.go
@@ -4,9 +4,11 @@ import (
 	"context"
 
 	"go.etcd.io/etcd/etcdserver/etcdserverpb"
+	"go.etcd.io/etcd/mvcc/mvccpb"
 )
 
 func isCompact(txn *etcdserverpb.TxnRequest) bool {
+	// See https://github.com/kubernetes/kubernetes/blob/442a69c3bdf6fe8e525b05887e57d89db1e2f3a5/staging/src/k8s.io/apiserver/pkg/storage/etcd3/compact.go#L72
 	return len(txn.Compare) == 1 &&
 		txn.Compare[0].Target == etcdserverpb.Compare_VERSION &&
 		txn.Compare[0].Result == etcdserverpb.Compare_EQUAL &&
@@ -18,14 +20,19 @@ func isCompact(txn *etcdserverpb.TxnRequest) bool {
 }
 
 func (l *LimitedServer) compact(ctx context.Context) (*etcdserverpb.TxnResponse, error) {
+	// return comparison failure so that the apiserver does not bother compacting
 	return &etcdserverpb.TxnResponse{
 		Header:    &etcdserverpb.ResponseHeader{},
-		Succeeded: true,
+		Succeeded: false,
 		Responses: []*etcdserverpb.ResponseOp{
 			{
-				Response: &etcdserverpb.ResponseOp_ResponsePut{
-					ResponsePut: &etcdserverpb.PutResponse{
+				Response: &etcdserverpb.ResponseOp_ResponseRange{
+					ResponseRange: &etcdserverpb.RangeResponse{
 						Header: &etcdserverpb.ResponseHeader{},
+						Kvs: []*mvccpb.KeyValue{
+							&mvccpb.KeyValue{},
+						},
+						Count: 1,
 					},
 				},
 			},
diff --git a/vendor/github.com/rancher/kine/pkg/server/create.go b/vendor/github.com/k3s-io/kine/pkg/server/create.go
similarity index 100%
rename from vendor/github.com/rancher/kine/pkg/server/create.go
rename to vendor/github.com/k3s-io/kine/pkg/server/create.go
diff --git a/vendor/github.com/rancher/kine/pkg/server/delete.go b/vendor/github.com/k3s-io/kine/pkg/server/delete.go
similarity index 100%
rename from vendor/github.com/rancher/kine/pkg/server/delete.go
rename to vendor/github.com/k3s-io/kine/pkg/server/delete.go
diff --git a/vendor/github.com/rancher/kine/pkg/server/get.go b/vendor/github.com/k3s-io/kine/pkg/server/get.go
similarity index 100%
rename from vendor/github.com/rancher/kine/pkg/server/get.go
rename to vendor/github.com/k3s-io/kine/pkg/server/get.go
diff --git a/vendor/github.com/rancher/kine/pkg/server/lease.go b/vendor/github.com/k3s-io/kine/pkg/server/lease.go
similarity index 100%
rename from vendor/github.com/rancher/kine/pkg/server/lease.go
rename to vendor/github.com/k3s-io/kine/pkg/server/lease.go
diff --git a/vendor/github.com/rancher/kine/pkg/server/limited.go b/vendor/github.com/k3s-io/kine/pkg/server/limited.go
similarity index 100%
rename from vendor/github.com/rancher/kine/pkg/server/limited.go
rename to vendor/github.com/k3s-io/kine/pkg/server/limited.go
diff --git a/vendor/github.com/rancher/kine/pkg/server/list.go b/vendor/github.com/k3s-io/kine/pkg/server/list.go
similarity index 100%
rename from vendor/github.com/rancher/kine/pkg/server/list.go
rename to vendor/github.com/k3s-io/kine/pkg/server/list.go
diff --git a/vendor/github.com/rancher/kine/pkg/server/server.go b/vendor/github.com/k3s-io/kine/pkg/server/server.go
similarity index 100%
rename from vendor/github.com/rancher/kine/pkg/server/server.go
rename to vendor/github.com/k3s-io/kine/pkg/server/server.go
diff --git a/vendor/github.com/rancher/kine/pkg/server/types.go b/vendor/github.com/k3s-io/kine/pkg/server/types.go
similarity index 100%
rename from vendor/github.com/rancher/kine/pkg/server/types.go
rename to vendor/github.com/k3s-io/kine/pkg/server/types.go
diff --git a/vendor/github.com/rancher/kine/pkg/server/update.go b/vendor/github.com/k3s-io/kine/pkg/server/update.go
similarity index 100%
rename from vendor/github.com/rancher/kine/pkg/server/update.go
rename to vendor/github.com/k3s-io/kine/pkg/server/update.go
diff --git a/vendor/github.com/rancher/kine/pkg/server/watch.go b/vendor/github.com/k3s-io/kine/pkg/server/watch.go
similarity index 90%
rename from vendor/github.com/rancher/kine/pkg/server/watch.go
rename to vendor/github.com/k3s-io/kine/pkg/server/watch.go
index b8b70de9d96..ff8007630e3 100644
--- a/vendor/github.com/rancher/kine/pkg/server/watch.go
+++ b/vendor/github.com/k3s-io/kine/pkg/server/watch.go
@@ -31,7 +31,7 @@ func (s *KVServerBridge) Watch(ws etcdserverpb.Watch_WatchServer) error {
 		if msg.GetCreateRequest() != nil {
 			w.Start(ws.Context(), msg.GetCreateRequest())
 		} else if msg.GetCancelRequest() != nil {
-			logrus.Debugf("WATCH CANCEL REQ id=%d", msg.GetCancelRequest().GetWatchId())
+			logrus.Tracef("WATCH CANCEL REQ id=%d", msg.GetCancelRequest().GetWatchId())
 			w.Cancel(msg.GetCancelRequest().WatchId, nil)
 		}
 	}
@@ -58,7 +58,7 @@ func (w *watcher) Start(ctx context.Context, r *etcdserverpb.WatchCreateRequest)
 
 	key := string(r.Key)
 
-	logrus.Debugf("WATCH START id=%d, count=%d, key=%s, revision=%d", id, len(w.watches), key, r.StartRevision)
+	logrus.Tracef("WATCH START id=%d, count=%d, key=%s, revision=%d", id, len(w.watches), key, r.StartRevision)
 
 	go func() {
 		defer w.wg.Done()
@@ -78,7 +78,7 @@ func (w *watcher) Start(ctx context.Context, r *etcdserverpb.WatchCreateRequest)
 
 			if logrus.IsLevelEnabled(logrus.DebugLevel) {
 				for _, event := range events {
-					logrus.Debugf("WATCH READ id=%d, key=%s, revision=%d", id, event.KV.Key, event.KV.ModRevision)
+					logrus.Tracef("WATCH READ id=%d, key=%s, revision=%d", id, event.KV.Key, event.KV.ModRevision)
 				}
 			}
 
@@ -92,7 +92,7 @@ func (w *watcher) Start(ctx context.Context, r *etcdserverpb.WatchCreateRequest)
 			}
 		}
 		w.Cancel(id, nil)
-		logrus.Debugf("WATCH CLOSE id=%d, key=%s", id, key)
+		logrus.Tracef("WATCH CLOSE id=%d, key=%s", id, key)
 	}()
 }
 
@@ -130,7 +130,7 @@ func (w *watcher) Cancel(watchID int64, err error) {
 	if err != nil {
 		reason = err.Error()
 	}
-	logrus.Debugf("WATCH CANCEL id=%d reason=%s", watchID, reason)
+	logrus.Tracef("WATCH CANCEL id=%d reason=%s", watchID, reason)
 	serr := w.server.Send(&etcdserverpb.WatchResponse{
 		Header:       &etcdserverpb.ResponseHeader{},
 		Canceled:     true,
diff --git a/vendor/github.com/rancher/kine/pkg/tls/config.go b/vendor/github.com/k3s-io/kine/pkg/tls/config.go
similarity index 100%
rename from vendor/github.com/rancher/kine/pkg/tls/config.go
rename to vendor/github.com/k3s-io/kine/pkg/tls/config.go
diff --git a/vendor/github.com/k3s-io/kine/scripts/build b/vendor/github.com/k3s-io/kine/scripts/build
new file mode 100755
index 00000000000..6e26f9c043f
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/build
@@ -0,0 +1,20 @@
+#!/bin/bash
+set -e
+
+source $(dirname $0)/version
+
+cd $(dirname $0)/..
+
+mkdir -p bin
+if [ "$(uname)" = "Linux" ]; then
+    OTHER_LINKFLAGS="-extldflags -static -s"
+fi
+LINKFLAGS="-X github.com/k3s-io/kine.Version=$VERSION"
+LINKFLAGS="-X github.com/k3s-io/kine.GitCommit=$COMMIT $LINKFLAGS"
+
+echo Building Kine
+go build -ldflags "$LINKFLAGS $OTHER_LINKFLAGS" -o bin/kine
+if [ "$CROSS" = "true" ] && [ "$ARCH" = "amd64" ]; then
+    GOOS=darwin go build -ldflags "$LINKFLAGS" -o bin/kine-darwin
+    GOOS=windows go build -ldflags "$LINKFLAGS" -o bin/kine-windows
+fi
diff --git a/vendor/github.com/k3s-io/kine/scripts/ci b/vendor/github.com/k3s-io/kine/scripts/ci
new file mode 100755
index 00000000000..577239c4230
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/ci
@@ -0,0 +1,12 @@
+#!/bin/bash
+set -e
+
+cd $(dirname $0)
+
+if [ -z "$SKIP_VALIDATE" ]; then
+  ./validate
+  ./validate-ci
+fi
+
+./build
+./package
diff --git a/vendor/github.com/k3s-io/kine/scripts/entry b/vendor/github.com/k3s-io/kine/scripts/entry
new file mode 100755
index 00000000000..78fb567905b
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/entry
@@ -0,0 +1,11 @@
+#!/bin/bash
+set -e
+
+mkdir -p bin dist
+if [ -e ./scripts/$1 ]; then
+    ./scripts/"$@"
+else
+    exec "$@"
+fi
+
+chown -R $DAPPER_UID:$DAPPER_GID .
diff --git a/vendor/github.com/k3s-io/kine/scripts/package b/vendor/github.com/k3s-io/kine/scripts/package
new file mode 100755
index 00000000000..b070753e3bf
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/package
@@ -0,0 +1,17 @@
+#!/bin/bash
+set -e
+
+cd $(dirname $0)/..
+
+. ./scripts/version
+
+mkdir -p dist/artifacts
+cp bin/kine dist/artifacts/kine${SUFFIX}
+file dist/artifacts/kine${SUFFIX}
+
+TAG=${TAG:-${VERSION_TAG}${SUFFIX}}
+IMAGE_NAME=${IMAGE_NAME:-kine}
+IMAGE=${REPO}/${IMAGE_NAME}:${TAG}
+
+docker build --build-arg ARCH=${ARCH} --tag ${IMAGE} -f package/Dockerfile .
+echo Built ${IMAGE}
diff --git a/vendor/github.com/k3s-io/kine/scripts/test b/vendor/github.com/k3s-io/kine/scripts/test
new file mode 100755
index 00000000000..dd1deacc5c4
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/test
@@ -0,0 +1,29 @@
+#!/bin/bash
+set -e
+
+cd $(dirname $0)/..
+
+. ./scripts/test-helpers
+
+#echo Running go unit tests
+go test -cover -tags=test ./...
+
+# ---
+
+docker ps
+
+# ---
+
+. ./scripts/test-run-sqlite
+echo "Did test-run-sqlite $?"
+
+. ./scripts/test-run-mysql
+echo "Did test-run-mysql $?"
+
+. ./scripts/test-run-postgres
+echo "Did test-run-postgres $?"
+
+. ./scripts/test-run-cockroachdb
+echo "Did test-run-cockroachdb $?"
+
+exit 0
diff --git a/vendor/github.com/k3s-io/kine/scripts/test-helpers b/vendor/github.com/k3s-io/kine/scripts/test-helpers
new file mode 100755
index 00000000000..66f278fff13
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/test-helpers
@@ -0,0 +1,320 @@
+#!/bin/bash
+
+# ---
+
+dump-logs() {
+    local testID=$(basename $TEST_DIR)
+    echo "#---------------------------------"
+    echo "#- Begin: logs for run ($testID)"
+    echo
+
+    for node in $TEST_DIR/*/*; do
+        [ -d "$node" ] || continue
+        local name=$(cat $node/metadata/name 2>/dev/null)
+        [ "$name" ] || continue
+        mkdir -p $node/logs
+        local hostname=$(docker exec $name hostname)
+        docker logs $name >$node/logs/system.log 2>&1
+        for log in $node/logs/*.log; do
+            echo
+            echo "#- Tail: $log"
+            tail -5 $log
+            echo "#- Done: $log"
+            echo
+        done
+    done
+    echo
+    echo "#- Finish: logs for run ($testID)"
+    echo "#---------------------------------"
+    echo
+}
+export -f dump-logs
+
+# ---
+
+test-cleanup() {
+    local code=$?
+    set +e
+    echo 'Cleaning up...'
+    trap - EXIT INT TERM
+    if [[ $code -ne 0 ]]; then
+        dump-logs
+    fi
+    for name in $TEST_DIR/*/*/metadata/name; do
+        [ -f "$name" ] || continue
+        local container=$(cat $name)
+        echo "Removing container $container"
+        docker rm -f -v $container
+    done
+    echo
+    if has-function test-post-hook; then
+      test-post-hook $code
+      code=$?
+    fi
+    if [ "$TEST_CLEANUP" = true ]; then
+        echo "Removing test directory $TEST_DIR"
+        rm -rf $TEST_DIR
+    fi
+    [ -f "$PROVISION_LOCK" ] && rm $PROVISION_LOCK
+    echo -n "Test $(basename $TEST_DIR) "
+    if [ $code -eq 0 ]; then
+        echo "passed."
+    else
+        echo "failed."
+    fi
+    echo
+    exit $code
+}
+export -f test-cleanup
+
+# ---
+
+test-setup() {
+    export TEST_DIR=$(mktemp -d '/tmp/XXXXXX')
+    trap test-cleanup EXIT INT TERM
+
+    mkdir -p $TEST_DIR/metadata
+    if [ "$LABEL" ]; then
+        exec > >(awk "{ printf \"[\033[36m${LABEL}\033[m] %s\n\", \$0; fflush() }") \
+            2> >(awk "{ printf \"[\033[35m${LABEL}\033[m] %s\n\", \$0; fflush() }" >&2)
+        echo "$LABEL" >$TEST_DIR/metadata/label
+    fi
+
+    mkdir -p $TEST_DIR/logs
+    exec > >(tee -a $TEST_DIR/logs/test.log) \
+        2> >(tee -a $TEST_DIR/logs/test.log >&2)
+
+    echo "Test $(basename $TEST_DIR) starting"
+}
+export -f test-setup
+
+# ---
+
+early-exit() {
+    printf "\033[33m$1\033[m\n"
+    exit $2
+}
+export -f early-exit
+
+# ---
+
+run-test() {
+    export PROVISION_LOCK=$(mktemp)
+    ./scripts/test-runner $@ &
+    pids+=($!)
+    (
+        set +x
+        while [ -f "$PROVISION_LOCK" ]; do
+            sleep 1
+        done
+        sleep 5
+    )
+}
+export -f run-test
+
+# ---
+
+inc-count() {(
+    shopt -s extglob
+    local count=$(exec 2>/dev/null; ls -1d $TEST_DIR/$1/+([0-9]) | xargs -n1 basename | sort -n -r | head -1)
+    count=$((count+1))
+    mkdir -p $TEST_DIR/$1/$count/metadata
+    echo $count
+)}
+export -f inc-count
+
+# ---
+
+has-function() {
+  [[ ! -z "$1" && $(type -t $1) == "function" ]]
+} 2> /dev/null
+export -f has-function
+
+# ---
+
+run-function() {
+    has-function $1 || return 0
+    $@
+}
+export -f run-function
+
+# ---
+
+wait-for-db-connection() {
+    if [ -z "$DB_CONNECTION_TEST" ]; then
+        echo 'DB_CONNECTION_TEST is not defined' >&2
+        return 1
+    fi
+    while ! $DB_CONNECTION_TEST 2>/dev/null; do
+        echo 'Waiting for database to become available...' >&2
+        sleep 5
+    done
+}
+export -f wait-for-db-connection
+
+# ---
+
+fetch-kubeconfig() {(
+    set -e -o pipefail
+    local num=${1:-1}
+    local name=$(cat $TEST_DIR/servers/$num/metadata/name)
+    local url=$(cat $TEST_DIR/servers/$num/metadata/url)
+    docker cp $name:/etc/rancher/k3s/k3s.yaml - 2>/dev/null | tar -xO 2>/dev/null | sed -e "s|https://127.0.0.1:6443|$url|g" >$TEST_DIR/servers/$num/kubeconfig.yaml
+)}
+export -f fetch-kubeconfig
+
+# ---
+
+wait-for-kubeconfig() {
+    while ! fetch-kubeconfig $1; do
+        echo 'Waiting for kubeconfig to become available...' >&2
+        sleep 5
+    done
+}
+export -f wait-for-kubeconfig
+
+# ---
+
+provision-cluster() {
+    run-function cluster-pre-hook
+
+    provision-server
+    timeout --foreground 120s bash -c "wait-for-kubeconfig $i"
+    export KUBECONFIG=$TEST_DIR/servers/1/kubeconfig.yaml
+
+    run-function cluster-post-hook
+}
+export -f provision-cluster
+
+# ---
+
+provision-server() {
+    local count=$(inc-count servers)
+    local testID=$(basename $TEST_DIR)
+    local name=$(echo "k3s-server-$count-$testID" | tee $TEST_DIR/servers/$count/metadata/name)
+
+    run-function server-pre-hook $count
+
+    docker run \
+        -d --name $name \
+        --privileged \
+        -p 6443 \
+        -e K3S_DEBUG=true \
+        -e K3S_DATASTORE_ENDPOINT=$K3S_DATASTORE_ENDPOINT \
+        ${K3S_IMAGE:-docker.io/rancher/k3s:v1.20.4-k3s1} server \
+        --disable=coredns,servicelb,traefik,local-storage,metrics-server \
+        --disable-agent --disable-scheduler --disable-cloud-controller --disable-kube-proxy --disable-network-policy
+
+    local ip=$(docker inspect --format '{{ .NetworkSettings.IPAddress }}' $name | tee $TEST_DIR/servers/$count/metadata/ip)
+    local port=$(docker inspect --format '{{range $k, $v := .NetworkSettings.Ports}}{{printf "%s\n" $k}}{{end}}' $name | head -n 1 | cut -d/ -f1 | tee $TEST_DIR/servers/$count/metadata/port)
+    local url=$(echo "https://$ip:$port" | tee $TEST_DIR/servers/$count/metadata/url)
+
+    echo "Started $name @ $url"
+    run-function server-post-hook $count
+}
+export -f provision-server
+
+# ---
+
+provision-kine() {
+    if [ -z "$KINE_IMAGE" ]; then
+        echo 'KINE_IMAGE is not defined' >&2
+        return 1
+    fi
+
+    local count=$(inc-count kine)
+    local testID=$(basename $TEST_DIR)
+    local name=$(echo "kine-$count-$testID" | tee $TEST_DIR/kine/$count/metadata/name) 
+
+    run-function kine-pre-hook $count
+
+    docker run \
+        -d --name $name \
+        $KINE_IMAGE --endpoint $KINE_ENDPOINT
+
+    local ip=$(docker inspect --format '{{.NetworkSettings.IPAddress}}' $name | tee $TEST_DIR/kine/$count/metadata/ip)
+    local port=$(docker inspect --format '{{range $k, $v := .NetworkSettings.Ports}}{{printf "%s\n" $k}}{{end}}' $name | head -n 1 | cut -d/ -f1 | tee $TEST_DIR/kine/$count/metadata/port)
+    local url=$(echo "http://$ip:$port" | tee $TEST_DIR/kine/$count/metadata/url)
+
+    run-function kine-post-hook $count
+
+    echo "Started $name @ $url"
+}
+export -f provision-kine
+
+# ---
+
+provision-database() {
+    if [ -z "$DB_IMAGE" ] || [ -z "$DB_PASSWORD_ENV" ]; then
+        return 0
+    fi
+
+    local count=$(inc-count databases)
+    echo > $TEST_DIR/databases/$count/metadata/env
+    echo $DB_IMAGE > $TEST_DIR/databases/$count/metadata/image
+    local testID=$(basename $TEST_DIR)
+    local name=$(echo "database-$count-$testID" | tee $TEST_DIR/databases/$count/metadata/name) 
+    local pass=$(echo "$RANDOM$RANDOM$RANDOM" | tee $TEST_DIR/databases/$count/metadata/password)
+    while [[ "$#" -gt "0" ]]; do
+      echo $1 >> $TEST_DIR/databases/$count/metadata/env
+      shift
+    done
+
+    run-function database-pre-hook $count
+
+    docker run \
+        -d --name $name \
+        --cap-add=sys_nice \
+        -e $DB_PASSWORD_ENV=$pass \
+        --env-file $TEST_DIR/databases/$count/metadata/env \
+        ${DB_IMAGE} ${DB_ARGS}
+
+    local ip=$(docker inspect --format '{{.NetworkSettings.IPAddress}}' $name | tee $TEST_DIR/databases/$count/metadata/ip)
+    local port=$(docker inspect --format '{{range $k, $v := .NetworkSettings.Ports}}{{printf "%s\n" $k}}{{end}}' $name | head -n 1 | cut -d/ -f1 | tee $TEST_DIR/databases/$count/metadata/port)
+
+    echo "Started $name @ $ip:$port"
+
+    run-function database-post-hook $count
+}
+export -f provision-database
+
+# ---
+
+pid-cleanup() {
+    local code=$?
+    local failCount=0
+    set +e
+    if [ $code -eq 0 ]; then
+        for pid in ${pids[@]}; do
+            wait $pid || code=$?
+        done
+    fi
+    if [ $code -ne 0 ]; then
+        for pid in ${pids[@]}; do
+            pkill -P $pid
+            wait $pid || failCount=$((failCount+1))
+        done
+    fi
+    trap - EXIT INT TERM
+    set +x
+    echo
+    if [ $failCount -eq 0 ]; then
+        printf '\033[32mAll tests passed.\033[m\n'
+    else
+        printf "\033[31m$failCount tests failed.\033[m\n"
+        if [ "$DRONE_BUILD_EVENT" = 'tag' ]; then
+            printf "\033[31mIgnoring test failures on tag.\033[m\n"
+            code=0
+        else
+            code=1
+        fi
+    fi
+    echo
+    exit $code
+}
+export -f pid-cleanup
+
+# ---
+
+pids=()
+trap pid-cleanup EXIT INT TERM
diff --git a/vendor/github.com/k3s-io/kine/scripts/test-load b/vendor/github.com/k3s-io/kine/scripts/test-load
new file mode 100755
index 00000000000..6ad2e0a74f7
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/test-load
@@ -0,0 +1,14 @@
+#!/bin/bash
+set -e
+cd $(dirname $0)/..
+
+test-load() {
+    for i in {1..4}; do
+        python3 hack/loadmap.py &
+    done
+    wait
+    python3 hack/histogram.py | awk '{print "[PERF]\t" $0}'
+}
+
+echo "Running configmap load generation script"
+test-load
diff --git a/vendor/github.com/k3s-io/kine/scripts/test-run-cockroachdb b/vendor/github.com/k3s-io/kine/scripts/test-run-cockroachdb
new file mode 100755
index 00000000000..dde4e9fbcba
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/test-run-cockroachdb
@@ -0,0 +1,37 @@
+#!/bin/bash
+
+start-test() {
+    local ip=$(cat $TEST_DIR/databases/*/metadata/ip)
+    local port=$(cat $TEST_DIR/databases/*/metadata/port)
+    local pass=$(cat $TEST_DIR/databases/*/metadata/password)
+    local test_image=docker.io/library/postgres:13.2
+    # https://github.com/k3s-io/kine/issues/44
+    case "$DB_IMAGE" in
+      *v20.2 ) local extra_params="&serial_normalization=sql_sequence" ;;
+      *      ) local extra_params="&experimental_serial_normalization=sql_sequence";;
+    esac
+
+    DB_CONNECTION_TEST="
+        docker run --rm
+        --name connection-test
+        $test_image
+        psql
+          --host=$ip
+          --port=$port
+          --username=root
+          --command=\\conninfo" \
+    timeout --foreground 1m bash -c "wait-for-db-connection"
+    KINE_IMAGE=$IMAGE KINE_ENDPOINT="postgres://root@$ip:$port/postgres?sslmode=disable$extra_params" provision-kine
+    local kine_url=$(cat $TEST_DIR/kine/*/metadata/url)
+    K3S_DATASTORE_ENDPOINT=$kine_url provision-cluster
+}
+export -f start-test
+
+VERSION_LIST="\
+    cockroachdb v20.2
+    cockroachdb v20.1
+    cockroachdb v19.2"
+
+while read ENGINE VERSION; do
+    LABEL=$ENGINE-$VERSION DB_PASSWORD_ENV=POSTGRES_PASSWORD DB_IMAGE=docker.io/$ENGINE/cockroach:latest-$VERSION DB_ARGS="start-single-node --insecure" run-test
+done <<< $VERSION_LIST
diff --git a/vendor/github.com/k3s-io/kine/scripts/test-run-mysql b/vendor/github.com/k3s-io/kine/scripts/test-run-mysql
new file mode 100755
index 00000000000..46b394c8ab9
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/test-run-mysql
@@ -0,0 +1,37 @@
+#!/bin/bash
+
+start-test() {
+    local ip=$(cat $TEST_DIR/databases/*/metadata/ip)
+    local port=$(cat $TEST_DIR/databases/*/metadata/port)
+    local pass=$(cat $TEST_DIR/databases/*/metadata/password)
+    local image=$(cat $TEST_DIR/databases/*/metadata/image)
+    DB_CONNECTION_TEST="
+        docker run --rm
+        --name connection-test
+        $image
+        mysql
+          --host=$ip
+          --port=$port
+          --user=root
+          --password=$pass
+          --execute=status" \
+    timeout --foreground 1m bash -c "wait-for-db-connection"
+    KINE_IMAGE=$IMAGE KINE_ENDPOINT="mysql://root:$pass@tcp($ip:$port)/kine" provision-kine
+    local kine_url=$(cat $TEST_DIR/kine/*/metadata/url)
+    K3S_DATASTORE_ENDPOINT=$kine_url provision-cluster
+}
+export -f start-test
+
+VERSION_LIST="\
+    mysql 8.0
+    mysql 5.7
+    mysql 5.6
+    mariadb 10.5
+    mariadb 10.4
+    mariadb 10.3
+    mariadb 10.2"
+
+while read ENGINE VERSION; do
+    LABEL=$ENGINE-$VERSION DB_PASSWORD_ENV=MYSQL_ROOT_PASSWORD DB_IMAGE=docker.io/library/$ENGINE:$VERSION run-test
+done <<< $VERSION_LIST
+
diff --git a/vendor/github.com/k3s-io/kine/scripts/test-run-postgres b/vendor/github.com/k3s-io/kine/scripts/test-run-postgres
new file mode 100755
index 00000000000..33fbdfeee8e
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/test-run-postgres
@@ -0,0 +1,36 @@
+#!/bin/bash
+
+start-test() {
+    local ip=$(cat $TEST_DIR/databases/*/metadata/ip)
+    local port=$(cat $TEST_DIR/databases/*/metadata/port)
+    local pass=$(cat $TEST_DIR/databases/*/metadata/password)
+    local image=$(cat $TEST_DIR/databases/*/metadata/image)
+    DB_CONNECTION_TEST="
+        docker run --rm
+        --name connection-test
+        -e PGPASSWORD=$pass
+        $image
+        psql
+          --host=$ip
+          --port=$port
+          --username=postgres
+          --command=\\conninfo" \
+    timeout --foreground 1m bash -c "wait-for-db-connection"
+    KINE_IMAGE=$IMAGE KINE_ENDPOINT="postgres://postgres:$pass@$ip:$port/postgres?sslmode=disable" provision-kine
+    local kine_url=$(cat $TEST_DIR/kine/*/metadata/url)
+    K3S_DATASTORE_ENDPOINT=$kine_url provision-cluster
+}
+export -f start-test
+
+VERSION_LIST="\
+    postgres 13.2
+    postgres 12.6
+    postgres 11.11
+    postgres 10.16
+    postgres 9.6
+    postgres 9.5"
+
+while read ENGINE VERSION; do
+    LABEL=$ENGINE-$VERSION DB_PASSWORD_ENV=POSTGRES_PASSWORD DB_IMAGE=docker.io/library/$ENGINE:$VERSION run-test
+done <<< $VERSION_LIST
+
diff --git a/vendor/github.com/k3s-io/kine/scripts/test-run-sqlite b/vendor/github.com/k3s-io/kine/scripts/test-run-sqlite
new file mode 100755
index 00000000000..ead033fac67
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/test-run-sqlite
@@ -0,0 +1,9 @@
+#!/bin/bash
+start-test() {
+    KINE_IMAGE=$IMAGE KINE_ENDPOINT="sqlite" provision-kine
+    local kine_url=$(cat $TEST_DIR/kine/*/metadata/url)
+    K3S_DATASTORE_ENDPOINT=$kine_url provision-cluster
+}
+export -f start-test
+
+LABEL=sqlite run-test
diff --git a/vendor/github.com/k3s-io/kine/scripts/test-runner b/vendor/github.com/k3s-io/kine/scripts/test-runner
new file mode 100755
index 00000000000..0417df8ab93
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/test-runner
@@ -0,0 +1,15 @@
+#!/bin/bash
+set -e
+cd $(dirname $0)/..
+
+. ./scripts/version
+
+TAG=${TAG:-${VERSION_TAG}${SUFFIX}}
+IMAGE_NAME=${IMAGE_NAME:-kine}
+IMAGE=${REPO}/${IMAGE_NAME}:${TAG}
+
+test-setup
+provision-database $DB_ARGS
+start-test $@
+
+./scripts/test-load
diff --git a/vendor/github.com/k3s-io/kine/scripts/validate b/vendor/github.com/k3s-io/kine/scripts/validate
new file mode 100755
index 00000000000..781e4d1d71b
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/validate
@@ -0,0 +1,19 @@
+#!/bin/bash
+set -e
+
+cd $(dirname $0)/..
+
+echo Running validation
+
+PACKAGES="$(go list ./...)"
+
+if ! command -v golangci-lint; then
+    echo Skipping validation: no golangci-lint available
+    exit
+fi
+
+echo Running: golangci-lint
+golangci-lint run
+
+echo Running: go fmt
+test -z "$(go fmt ${PACKAGES} | tee /dev/stderr)"
diff --git a/vendor/github.com/k3s-io/kine/scripts/validate-ci b/vendor/github.com/k3s-io/kine/scripts/validate-ci
new file mode 100755
index 00000000000..e7981cf8916
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/validate-ci
@@ -0,0 +1,15 @@
+#!/bin/bash
+set -e
+
+cd $(dirname $0)/..
+
+go generate
+
+source ./scripts/version
+
+if [ -n "$DIRTY" ]; then
+    echo Git is dirty
+    git status
+    git diff
+    exit 1
+fi
diff --git a/vendor/github.com/k3s-io/kine/scripts/version b/vendor/github.com/k3s-io/kine/scripts/version
new file mode 100755
index 00000000000..4343cf56fb6
--- /dev/null
+++ b/vendor/github.com/k3s-io/kine/scripts/version
@@ -0,0 +1,34 @@
+#!/bin/bash
+
+if [ -n "$(git status --porcelain --untracked-files=no)" ]; then
+    DIRTY="-dirty"
+fi
+
+COMMIT=$(git rev-parse --short HEAD)
+GIT_TAG=${DRONE_TAG:-$(git tag -l --contains HEAD | head -n 1)}
+
+if [ -z "$DIRTY" ] && [ -n "$GIT_TAG" ]; then
+    VERSION=$GIT_TAG
+else
+    VERSION="${COMMIT}${DIRTY}"
+fi
+
+if [ -n "$ARCH" ]; then
+    GOARCH=${ARCH}
+fi
+if [ -z "$GOARCH" ]; then
+    GOARCH=$(go env GOHOSTARCH)
+fi
+if [ "$GOARCH" = "arm" ]; then
+    GOARM=7
+fi
+
+ARCH="${GOARCH}"
+SUFFIX="-${ARCH}"
+
+TAG=${TAG:-${VERSION}${SUFFIX}}
+REPO=${REPO:-rancher}
+
+if echo $TAG | grep -q dirty; then
+    TAG=dev
+fi
diff --git a/vendor/github.com/rancher/kine/pkg/drivers/dqlite/no_dqlite.go b/vendor/github.com/rancher/kine/pkg/drivers/dqlite/no_dqlite.go
deleted file mode 100644
index 85f4636687c..00000000000
--- a/vendor/github.com/rancher/kine/pkg/drivers/dqlite/no_dqlite.go
+++ /dev/null
@@ -1,14 +0,0 @@
-// +build !dqlite
-
-package dqlite
-
-import (
-	"context"
-	"fmt"
-
-	"github.com/rancher/kine/pkg/server"
-)
-
-func New(ctx context.Context, datasourceName string) (server.Backend, error) {
-	return nil, fmt.Errorf("dqlite is not support, compile with \"-tags dqlite\"")
-}
diff --git a/vendor/github.com/rancher/kine/pkg/drivers/sqlite/sqlite_nocgo.go b/vendor/github.com/rancher/kine/pkg/drivers/sqlite/sqlite_nocgo.go
deleted file mode 100644
index bdf5977f106..00000000000
--- a/vendor/github.com/rancher/kine/pkg/drivers/sqlite/sqlite_nocgo.go
+++ /dev/null
@@ -1,26 +0,0 @@
-// +build !cgo
-
-package sqlite
-
-import (
-	"context"
-	"database/sql"
-	"errors"
-
-	"github.com/rancher/kine/pkg/drivers/generic"
-	"github.com/rancher/kine/pkg/server"
-)
-
-var errNoCgo = errors.New("this binary is built without CGO, sqlite is disabled")
-
-func New(ctx context.Context, dataSourceName string) (server.Backend, error) {
-	return nil, errNoCgo
-}
-
-func NewVariant(driverName, dataSourceName string) (server.Backend, *generic.Generic, error) {
-	return nil, nil, errNoCgo
-}
-
-func setup(db *sql.DB) error {
-	return errNoCgo
-}
-- 
2.25.1

